{"meta":{"title":"Tanjunze笔记","subtitle":null,"description":"tanjunze","author":"tanjunze","url":"https://tanjunze.github.io"},"pages":[{"title":"关于","date":"2018-10-26T13:59:02.000Z","updated":"2019-02-21T02:01:08.921Z","comments":true,"path":"about/index.html","permalink":"https://tanjunze.github.io/about/index.html","excerpt":"","text":"『 不积跬步无以至千里，不积小流无以成江海 』 关于我Android技术宅，计算机专业，喜欢折腾。技术栈: Java/Android/Kotlin、Flutter(强烈推荐)、H5、ReactNative、Weex、Cordova、Linux、SQl、TensorFlow、C++ 联系方式邮箱：tan_junze@qq.com Github：https://github.com/tanjunze"},{"title":"categories","date":"2019-03-14T02:21:07.995Z","updated":"2019-02-21T01:44:35.449Z","comments":true,"path":"categories/index.html","permalink":"https://tanjunze.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-14T02:21:08.010Z","updated":"2019-02-21T01:43:43.904Z","comments":true,"path":"tags/index.html","permalink":"https://tanjunze.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java JVM","slug":"Java JVM","date":"2019-01-16T21:02:14.000Z","updated":"2019-03-26T07:25:01.608Z","comments":true,"path":"2019/01/17/Java JVM/","link":"","permalink":"https://tanjunze.github.io/2019/01/17/Java JVM/","excerpt":"","text":"JVM机制java的构成及关系 java虚拟机的体系结构 每个Java虚拟机都有2中机制 类装载子系统 装载具有适合名称的类或接口。 执行引擎 负责执行包含在已装载的类或接口中的指令。 Java 垃圾回收原理 整理至：JVM 的 工作原理，层次结构 以及 GC工作原理 垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。GC是后台的守护进程。它的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况动态的调整他的优先级。因此，它是在内存中低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。 为何要这样设计：因为GC也是进程，也要消耗CPU等资源，如果GC执行过于频繁会对java的程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选着了不定期的gc。 GC有关的是: runtime data area 中的 heap（对象实例会存储在这里） 和 gabage collector方法。 程序运行期间，所有对象实例存储在运行时数据区域的heap中，当一个对象不再被引用（使用），它就需要被收回。在GC过程中，这些不再被使用的对象从heap中收回，这样就会有空间被循环利用。 GC为内存中不再使用的对象进行回收，GC中调用回收的方法–收集器garbage collector. 由于GC要消耗一些资源和时间，Java 在对对象的生命周期特征（eden or survivor）进行分析之后，采用了分代的方式进行对象的收集，以缩短GC对应用造成的暂停。 Java内存结构 新生代（Young Generation） 大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。 新生代内又分三个区：一个Eden区，两个Survivor区（一般而言），大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。 老年代（Old Generation） 在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。 永久代（Perm Generation） 主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。 永久代在Java SE8特性中已经被移除，引入了MetaSpace 。 常见的垃圾回收器不同的垃圾回收器，适用于不同的场景。常用的垃圾回收器： 串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。 并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。 吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。 并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。 Java对象的引用 强引用（Strong Reference） 是最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。 软引用（Soft Reference） SoftReference&lt;&gt; 修饰的对象具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 弱引用（Weak Reference） 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 虚引用（Phantom Reference） “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 在内存不足时 对象缓存 内存不足时终止 弱引用 在垃圾回收时 对象缓存 gc运行后终止 虚引用 Unknown Unknown Unknown 参考： (转)Java 详解 JVM 工作原理和流程 JVM 的 工作原理，层次结构 以及 GC工作原理 浅析JAVA的垃圾回收机制（GC） 从实际案例聊聊Java应用的GC优化 Java 7之基础 - 强引用、弱引用、软引用、虚引用","categories":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/tags/java/"}]},{"title":"Java HashMap","slug":"Java HashMap","date":"2019-01-12T21:18:03.000Z","updated":"2019-03-26T07:24:22.403Z","comments":true,"path":"2019/01/13/Java HashMap/","link":"","permalink":"https://tanjunze.github.io/2019/01/13/Java HashMap/","excerpt":"","text":"HashMapHashMapHashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap 1Map map = Collections.synchronizedMap(new HashMap()); HashMap数据结构HashMap的底层主要基于数组和链表实现的，它之所以查询速度相当快主要因为它通过计算散列码来决定存储的位置。HashMap主要通过key的hashcode来计算hash值，只有hashcode相同，计算出来的hash值就一样，就会出现hash冲突。HashMap底层是通过链表来解决hash冲突的。 HashMap中有数组和链表(1.8之后根据阈值使用红黑数)来实现存储： 数组： 数组存储区间是连续的，占用内存严重，故空间复杂度大。但数组的二分查找时间复杂度小，为O(1)； 数组特点：寻址容易，插入和删除困难； 链表 链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表特点：寻址困难，插入和删除容易。 哈希表 综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构，这就是哈希表。 哈希表有多种不同的实现方法，HashMap则使用的是拉链法，也叫作【链地址法】； HashMap的存储HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor) size size表示HashMap中存放KV的数量（为链表和树中的KV的总和） Capacity capacity就是指HashMap中桶(数组)的数量。默认值为16。一般第一次扩容时会扩容到64。容量都是2的幂。 loadFactor 装载因子。装载因子用来衡量HashMap满的程度。loadFactor的默认值为0.75f。计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity。 put函数的实现 对key的hashCode()做hash，再计算（index = (array.length - 1) &amp; hash]）当前key需要存储数组的位置;（不顺序的原因） 如果没碰撞，直接放到数组中； 如果碰撞了，当前数组位置的链表中； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果数组满了(超过load factor*current capacity)，就要resize。 get函数的实现 bucket（数组）里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。 参考： 数据结构】HashMap原理及实现学习总结 HashMap结构详解 HashMap设计原理、HashMap的数据结构、HashMap源码实现 Java HashMap工作原理及实现 HashMap中capacity、loadFactor、threshold、size等概念的解释 HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！","categories":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/tags/java/"}]},{"title":"Java数据结构","slug":"Java数据结构","date":"2018-12-29T16:08:56.000Z","updated":"2019-03-26T07:28:30.028Z","comments":true,"path":"2018/12/30/Java数据结构/","link":"","permalink":"https://tanjunze.github.io/2018/12/30/Java数据结构/","excerpt":"","text":"来源： Java集合干货系列-集合总体大纲 深入Java源码解析容器类List、Set、Map","categories":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/tags/java/"}]},{"title":"Java 基础知识","slug":"Java基础知识","date":"2018-12-09T23:38:33.000Z","updated":"2019-03-26T07:27:32.980Z","comments":true,"path":"2018/12/10/Java基础知识/","link":"","permalink":"https://tanjunze.github.io/2018/12/10/Java基础知识/","excerpt":"","text":"Java 三大特性1、封装定义：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。 好处: 减少耦合 类内部的结构可以自由修改 可以对成员变量进行精准控制 隐藏信息，实现细节 权限修饰符 修饰符 同一类 同一包 不同包的子类 不同包的非子类 private √ default √ √ protected √ √ √ public √ √ √ √ 2、继承定义： 子类继承父类的特征和行为。在java中使用extends实现继承父类 好处： 实现代码的复用 分类： 单继承 子类只有一个父类的关系称为单继承。在java中使用extends实现 多继承 子类有多个父类的关系称为多继承。java 中不支持多继承，但可以使用implements实现多继承。 1234567891011public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; 3、多态定义：多态是同一个行为具有多个不同表现形式或形态的能力 好处： 类型间的解耦 扩展性和维护性 多态的必要条件： 继承 重写（重新定义父类方法） 向上转型（父类引用指向子类对象） 多态的实现： 基于继承实现 子类重写父类方法，使多个子类对同一方法的重写可以表现不同的行为。 基于接口实现 通过实现接口并覆盖接口中的方法，同一接口下的子类方法具有不同的行为。 抽象类和接口抽象类定义：使用abstract修饰的类。 特点： 抽象类不能直接实例化。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象方法只是声明，不能实现，必须在子类中实现 #####接口 定义：使用interface修饰的类 特点：： 接口是隐式抽象的，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的。且是public 接口中的方法都是public。 接口允许继承和多继承。 一个类可以实现多个接口 接口中的变量会被隐式的指定为 public static final 变量 实现： 使用implements实现接口，可以继承接口，也一个多继承。 String 、StringBuffer 、StringBuiderString： 是由final修饰的char数组构成的字符串常量，只能赋值一次，字符串长度不可变。String 使用‘+’号拼接时jvm会隐式的转换成StringBuilder拼接字符串。在单行用加号拼接字符串是没有性能损失的，有循环的情况下，仍然会有不必要的性能损耗 。 String不可变对象的理解。String 在赋值，替换等操作会创建新String对象，原对象没有改变，依然在内存中。指向原对象的引用在赋值，替换等操作后指向创建的新String对象。 StringBuffer：线程安全的可变字符串。 StringBuilder：非线程安全的可变字符串。 反射定义：Java中允许运行时操作类或者获取对象内部属性的机制。 注解定义：Java标注，可以在代码中插入元数据的语法。在代码使用注解可以通过反射获取标注的内容。 作用： 编写文档：通过代码里标识的元数据生成文档； 代码分析：通过代码里标识的元数据对代码进行分析； 编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查； 内置注解： @Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 注解的注解： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 12345678@Inherited@Retention(RetentionPolicy.RUNTIME)@interface InheritedTest &#123;&#125;@InheritedTestpublic class Parent&#123;&#125;public class Child extends Parent &#123;&#125; 如代码所示，Child类继承了含有InheritedTest注解的Parent类，此时Child也含有相同的注解。 @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 自定义注解 使用@interface声明注解 123456// 1、声明Test标注public @interface Test &#123;&#125;// 2、使用注解@Testpublic void open()&#123;&#125; 注解中的属性 123456789101112131415161718@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; String name() default \"java\"; int phone() default 1111111;&#125;@TestAnnotation(name=\"tanzj\",phone=1788888888)public class Test &#123;&#125;//默认注解，注解内仅有一个value属性。public @interface Check &#123; String value();&#125;@Check(\"hi\")int a;@Check(value=\"hi\")int a; 注解的提取 注解是的提取是使用反射获取的。 通过 Class 对象的isAnnotationPresent() 方法判断它是否应用了某个注解 通过getAnnotation() 或 getAnnotations()方法来获取 Annotation 对象 123456789101112@TestAnnotation()public class Test &#123; public static void main(String[] args) &#123; //1. boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; //2. TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println(\"name:\"+testAnnotation.name()); System.out.println(\"phone:\"+testAnnotation.phone()); &#125; &#125;&#125; 应用实例 JUnit，ButterKnife，Dagger2，Retrofit等。 依赖注入依赖抽象，用于代码的解耦。 Java代理代理是一种设计模式，为其他对象提供一个代理已控制对象的访问。主要为了解耦操作。 静态代理 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 1、代理接口 */public interface ISubject &#123; public void doSomething(String something);&#125;/** * 2、真实的委托类 */public class RealSubject implements ISubject &#123; @Override public void doSomething(String something)&#123; System.out.println(\"正在做：\" + something); &#125;&#125;/** * 3、代理类 */public class ProxySubject implements ISubject &#123; //代理类持有一个委托类的对象引用 private ISubject delegate; public ProxySubject() &#123; &#125; private ISubject getISubject()&#123; if (delegate==null) &#123; delegate=new RealSubject(); &#125; return delegate; &#125; @Override public void doSomething(String something)&#123; //调用真实的委托类处理 getISubject().doSomething(something); &#125;&#125;/** * 4、调用委托类 */public class Client1 &#123; public static void main(String[] args) &#123; ISubject proxy =new ProxySubject() proxy.doSomething(\"codeing\"); &#125;&#125; 优点： 业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。 缺点： 1、代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。 2、如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 动态代理 定义：在运行期间确定代理类和委托类之间的关系。 1234567891011// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器 static InvocationHandler getInvocationHandler(Object proxy) // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象 static Class getProxyClass(ClassLoader loader, Class[] interfaces) // 方法 3：该方法用于判断指定类对象是否是一个动态代理类 static boolean isProxyClass(Class cl) // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 123456789101112131415161718/** * 动态代理类对应的调用处理程序类 */ public class SubjectInvocationHandler implements InvocationHandler &#123; //代理类持有一个委托类的对象引用 private Object delegate; public SubjectInvocationHandler(Object delegate) &#123; this.delegate = delegate; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //利用反射机制将请求分派给委托类处理。Method的invoke返回Object对象作为方法执行结果。 Object result=method.invoke(delegate, args); return result; &#125; &#125; 12345678public class Test &#123; public static void main(String[]args) &#123; ISubject delegate=new RealSubject(); InvocationHandler handler=new SubjectInvocationHandler(delegate); Sales proxy=(Sales)Proxy.newProxyInstance(delegate.getClass().getClassLoader(), delegate.getClass().getInterfaces(), handler); proxy.doSomething(\"coding\"); &#125;&#125; 优点： 动态代理类在运行时有Java反射生成，更加灵活。 缺点： 动态代理机制只能代理实现了接口的类 浅拷贝与深拷贝 浅拷贝 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 常见问题 多态的机制 动态绑定，即父类引用指向子类对象。 接口与类的区别 接口不能示例化，类可以。 接口没有构造函数，类有。 接口中的所有方法都是抽象的。 接口不能被类继承只能实现。 接口支持多继承。 接口与抽象类的区别 抽象类中方法可以有方法的实现。接口方法不行。 抽象类中的成员变量可以是任意类型，接口中的成员变量只能是public static final类型的。 抽象类中可以有静态代码块和静态方法，接口没有。 一个类只能继承一个抽象类，一个类可以实现多个接口 抽象类可以用final声明么？ 不能，抽象类必须有子类，使用final 定义的类不能有子类。 抽象类可以用static声明么？ 可以在内部抽象类中使用。使用static申明的内部类属于外部类。 父类的静态方法能不能被子类重写？ 不能。 Java 中的 ==, equals 与 hashCode 的区别 == 基本数据类型时，判断值是否相等。 引用数据类型时，判断内存地址是否相等即是否是同一个对象。 equals 判断对象是否一致 hashCode 表示对象的唯一性，用来快速检索对象。 参考： runoob Java抽象类 详解 Java：String、StringBuffer和StringBuilder的区别 解读不可变的String 为什么String要设计成不可变的? Java 中的 ==, equals 与 hashCode 的区别与联系 Java注解 秒懂，Java 注解 （Annotation）你可以这样学 Java注解深入理解 Java静态代理和动态代理 Java代理和动态代理机制分析和应用","categories":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/tags/java/"}]},{"title":"私有Dart Package Sever","slug":"Dart Package Server","date":"2018-10-12T00:00:00.000Z","updated":"2018-12-28T05:43:44.146Z","comments":true,"path":"2018/10/12/Dart Package Server/","link":"","permalink":"https://tanjunze.github.io/2018/10/12/Dart Package Server/","excerpt":"","text":"搭建私有 Dart Package Server1、搭建Dart Package Server","categories":[{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/categories/前端/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://tanjunze.github.io/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"https://tanjunze.github.io/tags/Flutter/"}]},{"title":"Docker命令笔记","slug":"Docker命令笔记","date":"2018-08-17T10:15:12.000Z","updated":"2019-02-26T07:18:10.976Z","comments":true,"path":"2018/08/17/Docker命令笔记/","link":"","permalink":"https://tanjunze.github.io/2018/08/17/Docker命令笔记/","excerpt":"一、Docker 安装本示例采用sh脚本安装,其他方式参考Docker CE官网。","text":"一、Docker 安装本示例采用sh脚本安装,其他方式参考Docker CE官网。 0、root用户登陆 1、升级yum包： $ sudo yum update 2、（可选）卸载旧的Docker $ sudo yum erase docker docker-common docker-client docker-compose 4、执行 Docker 安装脚本 $ curl -fsSL https://get.docker.com/ | sh或$ wget -qO- https://get.docker.com/ | sh 5、测试Docker $ docker info 6、设置Docker开机启动 $ sudo systemctl enable docker.service 7、开启Docker服务 $ sudo systemctl start docker 二、Docker Compose 安装 1、下载安装脚本 $ curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s-uname -m` -o /usr/local/bin/docker-compose 2、添加执行权限 $ chmod +x /usr/local/bin/docker-compose 三、Docker 常用命令 Docker 启动 $ sudo systemctl start docker docker 开机启动 $ sudo systemctl enable docker.service docker 当前容器开机启动 $ docker run -d –restart=always 容器终端 $ docker exec -it &lt;容器id&gt; /bin/bash 挂载目录 $ docker run -d -v &lt;主机目录路径&gt;:&lt;容器目录路径 &gt; 示例： $ docker run -d –restart=always -v /root/notebooks:/notebooks -it -p 8888:8888 tensorflow/tensorflow:latest-py3 拉取镜像 $ docker pull &lt;镜像tag&gt; 查看运行中的容器 $ docker ps 查看所有容器 $ docker ps -a 关闭容器 $ docker stop &lt;容器id&gt; 强制删除容器 $ docker rm -f &lt;容器id&gt; 查看镜像文件 $ docker images 删除镜像文件 docker rmi &lt;镜像id&gt; 参考文档 [1]、Docker CE [2]、Docker Compose [3]、Docker 常用命令与操作","categories":[{"name":"Docker","slug":"Docker","permalink":"https://tanjunze.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://tanjunze.github.io/tags/Docker/"}]},{"title":"Flutter 整理","slug":"Flutter整理2","date":"2018-07-12T21:22:10.000Z","updated":"2019-02-26T07:17:26.469Z","comments":true,"path":"2018/07/13/Flutter整理2/","link":"","permalink":"https://tanjunze.github.io/2018/07/13/Flutter整理2/","excerpt":"","text":"Dart Packagehttps://www.dartlang.org/tools/pub 创建dart 包https://www.dartlang.org/guides/libraries/create-library-packages dart包依赖https://www.dartlang.org/tools/pub/dependencies#path-packages 依赖自建 pub serverhttps://www.dartlang.org/tools/pub/dependencies#hosted-packages 自建私有服务器Github： pub server 依赖Git仓库https://www.dartlang.org/tools/pub/dependencies#git-packages 本地仓库依赖https://www.dartlang.org/tools/pub/dependencies#path-packages Flutter Packagehttps://flutter.io/docs/development/packages-and-plugins/using-packages 开发Flutter包https://flutter.io/docs/development/packages-and-plugins/developing-packages","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tanjunze.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tanjunze.github.io/tags/Flutter/"},{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/tags/前端/"}]},{"title":"Android Binder 机制","slug":"Android Binder 机制","date":"2018-06-17T16:22:04.000Z","updated":"2019-02-28T05:42:17.087Z","comments":true,"path":"2018/06/18/Android Binder 机制/","link":"","permalink":"https://tanjunze.github.io/2018/06/18/Android Binder 机制/","excerpt":"","text":"Android Binder 机制Binder 在Android是一个重要的机制。(待补充) 参考： [1]、彻底理解Android Binder通信架构","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Flutter 整理","slug":"Flutter整理","date":"2018-06-04T21:00:05.000Z","updated":"2019-02-26T07:18:02.078Z","comments":true,"path":"2018/06/05/Flutter整理/","link":"","permalink":"https://tanjunze.github.io/2018/06/05/Flutter整理/","excerpt":"","text":"文档Flutter 官网 https://flutter.io/ Flutter 中文 官方：https://flutter-io.cn/ 社区：https://flutterchina.club/ Dart官网 https://www.dartlang.org/ Dart包管理 https://pub.dartlang.org/ https://pub.flutter-io.cn/ Flutter 桌面版 社区：https://github.com/google/flutter-desktop-embedding 其他：https://feather-apps.com/ codelabs中文：https://codelabs.flutter-io.cn/ 工具json_serializable https://caijinglong.github.io/json2dart/index_ch.html 动画 https://www.2dimensions.com/runtimes 博文闲鱼 https://www.yuque.com/xytech/flutter","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://tanjunze.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tanjunze.github.io/tags/Flutter/"},{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/tags/前端/"}]},{"title":"linux笔记之ssh","slug":"linux笔记之ssh","date":"2018-05-23T10:08:33.000Z","updated":"2019-02-26T06:30:22.051Z","comments":true,"path":"2018/05/23/linux笔记之ssh/","link":"","permalink":"https://tanjunze.github.io/2018/05/23/linux笔记之ssh/","excerpt":"1、ssh自动脚本登陆 1.1、创建shell脚本，如脚本 login.sh内容如下： 1234567#!/usr/bin/expect set timeout 3 spawn ssh user@192.168.3.24 expect \"*password*\" send \"youPassword\\r\" interact","text":"1、ssh自动脚本登陆 1.1、创建shell脚本，如脚本 login.sh内容如下： 1234567#!/usr/bin/expect set timeout 3 spawn ssh user@192.168.3.24 expect \"*password*\" send \"youPassword\\r\" interact 1.2、为自动登陆脚本添加执行权限，如： $ sudo chmod +x ./login.sh 1.3、（可选）为脚本添加别名 打开用户目录下的.bash_profile文件 $ vim ~/.bash_profile 添加 别名（如：SSLogin）和 脚本路径（如：/Users/youAccount/home/login.sh）保存并退出， 如： $ alias SSLogin=’/Users/youAccount/home/login.sh’ 刷新环境变量 $ source ~/.bash_profile 在终端中直接使用别名 SSLogin去登陆了,如 $ SSLogin 2、ssh免密码登陆 参考博文：SSH免密码登陆和免ip连接 参考网址： [1]、expect教程中文版 [2]、shell实现SSH自动登陆","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tanjunze.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tanjunze.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://tanjunze.github.io/tags/SSH/"}]},{"title":"MAC命令","slug":"Mac 命令收集","date":"2018-05-22T15:56:43.000Z","updated":"2019-02-26T06:29:55.432Z","comments":true,"path":"2018/05/22/Mac 命令收集/","link":"","permalink":"https://tanjunze.github.io/2018/05/22/Mac 命令收集/","excerpt":"","text":"Mac 命令打开关闭隐藏文件及目录1shift commond .","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tanjunze.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tanjunze.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://tanjunze.github.io/tags/SSH/"},{"name":"Mac","slug":"Mac","permalink":"https://tanjunze.github.io/tags/Mac/"}]},{"title":"树莓派笔记之自动挂载nfts移动硬盘","slug":"树莓派笔记之自动挂载nfts移动硬盘","date":"2018-05-21T14:52:53.000Z","updated":"2018-10-26T05:52:43.901Z","comments":true,"path":"2018/05/21/树莓派笔记之自动挂载nfts移动硬盘/","link":"","permalink":"https://tanjunze.github.io/2018/05/21/树莓派笔记之自动挂载nfts移动硬盘/","excerpt":"0、插入ntfs的存储设备如：移动硬盘1、安装ntfs-3g $ sudo apt-get install ntfs-3g 2、查询外接存储目录权限和UUID $ ls -l /dev/disk/by-uuid/ 输出：1lrwxrwxrwx 1 root root 10 Jan 1 1970 0AC4D607C4D5F543 - &gt; ../../sda1 记下UUID - &gt; 0AC4D607C4D5F543的值","text":"0、插入ntfs的存储设备如：移动硬盘1、安装ntfs-3g $ sudo apt-get install ntfs-3g 2、查询外接存储目录权限和UUID $ ls -l /dev/disk/by-uuid/ 输出：1lrwxrwxrwx 1 root root 10 Jan 1 1970 0AC4D607C4D5F543 - &gt; ../../sda1 记下UUID - &gt; 0AC4D607C4D5F543的值 3、创建挂载点并赋权 $ sudo mkdir /mnt/usbdrive $ sudo chmod 770 /mnt/usbdrive 4、使用id命令获取uid，pi用户和组的gid（通常为1000） $ id -u pi $ id -g pi 5、挂载，然后检查/mnt/usbdrive是否可以访问它 $ sudo mount -t ntfs-3g -o uid=1000，gid=1000，umask=007 /dev/sda1/mnt/usbdrive 6、备份驱动目录并插入新的挂载点备份： $ sudo cp /etc/fstab /etc/fstab.backup 打开驱动目录文件并在最后一行写入新的驱动信息 $ sudo nano /etc/fstab 在fstab文件中添加安装信息（用您自己的UUID，uid，gid替换）：1UUID=0AC4D607C4D5F543 /mnt/usbdrive ntfs-3g uid=1000，gid=1000，umask=007 0 0 7、重新启动树莓派 sudo reboot 8、作为NextCloud的存储设备在/mnt/usbdrive驱动（移动硬盘）上配置NextCloud的数据目录，则它应该对www-data用户拥有770权限。您可以简单地将用户www-data添加到pi组中，因为它已经拥有770的权限，如上面在fstab中设置的那样。 $ sudo usermod -a -G pi www-data 参考网址： [1]、How to setup mount / auto-mount USB Hard Drive on Raspberry Pi [2]、NTFS External HD With ownCloud on the Raspberry Pi [3]、NTFS-3g HDD 0770 and 0777 permissions Owncloud [4]、通过 NextCloudPi 为树莓派可视化搭建 NextCloud 网盘（并折腾无语的 NTFS 移动硬盘） [5]、给树莓派挂载移动硬盘或U盘 [6]、树莓派Raspberry Pi 打造低成本NAS存储家庭服务器的十个问题整理","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/categories/树莓派/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/tags/树莓派/"}]},{"title":"树莓派笔记之NextCloud安装","slug":"树莓派笔记之NextCloud安装","date":"2018-05-21T13:32:27.000Z","updated":"2018-10-26T05:52:34.453Z","comments":true,"path":"2018/05/21/树莓派笔记之NextCloud安装/","link":"","permalink":"https://tanjunze.github.io/2018/05/21/树莓派笔记之NextCloud安装/","excerpt":"Nextcloud 是一个免费专业的私有云存储网盘「开源」项目，可以让你简单快速地在个人/公司电脑、服务器甚至是树莓派等设备上架设一套属于自己或团队专属的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。 1、NextCloud简单安装的三种方式总结 1.1、使用 docker 安装：文档：https://github.com/nextcloud/docker 1.2、使用 nextcloud-snap 安装文档：https://github.com/nextcloud/nextcloud-snap 1.3 使用VM安装文档：https://github.com/nextcloud/vm","text":"Nextcloud 是一个免费专业的私有云存储网盘「开源」项目，可以让你简单快速地在个人/公司电脑、服务器甚至是树莓派等设备上架设一套属于自己或团队专属的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。 1、NextCloud简单安装的三种方式总结 1.1、使用 docker 安装：文档：https://github.com/nextcloud/docker 1.2、使用 nextcloud-snap 安装文档：https://github.com/nextcloud/nextcloud-snap 1.3 使用VM安装文档：https://github.com/nextcloud/vm NextCloud安装官方文档：https://nextcloud.com/install/#instructions-server 2、NextCloud在树莓派上的安装方式NextCloudPI官方文档：https://github.com/nextcloud/nextcloudpi 2.1、自己构建环境和部署NextCloud博文：在Raspberry Pi上简单安装Nextcloud 2.1、自动脚本构建NextCloud博文：在Raspberry Pi上自动安装Nextcloud 2.3、刷NextCloudPi镜像文件博文：树莓派Raspberry Pi安装NextCloud教程-自建家庭私有云局域网共享 2.4 使用 docker 安装：文档：NextCloudPI Github 3、NextCloud快速安装笔记 这里记录我目前使用的安装方式 步骤2.1中关键命令，方便查阅： 3.1、下载Ansible $ sudo apt-get -y install ansible 3.2、下载自动构建脚本 $ wget https://raw.githubusercontent.com/webtaster/Nextcloud/master/build_nextcloud.yml 3.3、(可选)使用 SQLite安装和配置Nextcloud $ sudo date ; ansible-playbook -s -c local -i “localhost,” build_nextcloud.yml 3.4、(可选)使用 MySQL安装和配置Nextcloud $ date ; ansible-playbook -s -c local -i “localhost,” –extra-vars “DATABASE=mysql MYSQL_ROOT_PASSWORD=qwerty NCUSER_PASSWORD=raindrop” build_nextcloud.yml 上面指令中MySQL用户密码（可以自定义）：用户：root 密码：qwerty 对应命令：MYSQL_ROOT_PASSWORD = qwerty用户：ncuser 密码：rainindrop 对应命令：NCUSER_PASSWORD = raindrop 3.5、初始化配置NextCloud在浏览器中打开 http://树莓派的IP地址/nextcloud 例如： http://192.168.1.99/nextcloud 然后根据NextCloud提示配置NextCloud就可以了。 3.6、(可选)配置树莓派目录读写权限如果在浏览器中配置NextCloud过程中错误提示“无法创建var/www/html/nextcloud/data“时，ssh等登陆树莓派并赋予775权限 $ sudo chmod -R 775 /var/www/html/nextcloud/","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/categories/树莓派/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/tags/树莓派/"}]},{"title":"树莓派笔记之安装配置","slug":"树莓派笔记之安装配置","date":"2018-05-21T09:38:43.000Z","updated":"2018-10-26T05:52:39.303Z","comments":true,"path":"2018/05/21/树莓派笔记之安装配置/","link":"","permalink":"https://tanjunze.github.io/2018/05/21/树莓派笔记之安装配置/","excerpt":"前言： 这篇笔记记录不使用显示屏和网线来安装系统和配置环境 1、准备 树莓派3b+板子 SD存储卡和卡套 电源线和插头 路由器（有wifi就行）","text":"前言： 这篇笔记记录不使用显示屏和网线来安装系统和配置环境 1、准备 树莓派3b+板子 SD存储卡和卡套 电源线和插头 路由器（有wifi就行） 2、\b刻录\b系统 2.1、到树莓派官网下载系统系统文件并解压 2.2、下载安装镜像刻录软件如：\bMac版Etcher和window版win32diskimager等 2.3、插入SD卡到电脑并打开刻录软件如：\b目前使用的Etcher（示例） 2.3.1、选择（Select image）\b\b从官网下载并解压\b后的 NOOBS \b或 RASPBIAN \b\b镜像文件（ xxx.img \b格式） 2.3.2、选择SD\b卡 (Select drive) 2.3.3 \b开始刻录镜像（Flash）并等待及几分钟至镜像刻录完成\b 3、\b\b配置wif\bi和ssh因为没有使用\b网线所以要在安装前配置好wifi和ssh，\b\b让\b\b板子在安装完系统后自动连接wifi并开启ssh。 3.1、配置wifi 打开SD卡，创建文件并写入保存：文件名：wpa_supplicant.conf 12345678910country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;ssid=&quot;mywifi&quot; #ssid（wifi名）psk=&quot;123456&quot; #password（wifi密码）key_mgmt=WPA-PSK #wifi加密方式priority=1 #优先级&#125; 3.2、配置ssh 打开SD卡，创建文件ssh文件(不写入内容，无后缀)文件名：ssh 4、安装系统并ssh登陆 4.1、将SD卡插入板子中并上电启动，如果绿灯不在闪烁且红灯常亮，那么系统安装并启动成功。 4.2、进入路由器查看名称为 raspberry设备的 IP地址，例如：设备：raspberry ，IP地址：192.168.1.56。如果没有查看到 raspberry设备和IP，请确认 步骤3.1 中文件 wpa_supplicant.conf是否正确配置wifi名称和密码。如果错误请重新刻录系统并配置wifi。 4.3、确认到 raspberry的IP（例如：192.168.1.56）后在电脑中打开终端（window使用xshell）连接到 Raspberry PI 板子的 ssh服务，例如： ssh pi@192.168.1.56 然后输入密码：raspberry(系统默认) 4.4、ssh登陆完成后就可以对板子操作了！ 5、设置wifi在板子断电或重启后自动连接网络 5.1、ssh登陆后执行 sudo nano /etc/network/interfaces 12345678910111213auto loiface lo inet loopbackiface eth0 inet dhcpallow-hotplug wlan0iface wlan0 inet dhcpwpa-ssid &quot;mywifi&quot;wpa-psk &quot;123456&quot; 保存退出 参考博文：Raspberry Pi树莓派无线网卡配置[多重方法备选] 6、安全管理 建议修改默认账户密码如： 用户：pi 密码：raspberry 注： 1、nano 编辑器 操作 退出：control x保存并退出： control o 保存 enter q确认 control x 退出 2、linxu c重启命令 sudo reboot 参考博文： [1]、树莓派如何完全无头(无屏无网线无键盘鼠标)安装 [2]、树莓派 - 修改pi账号密码,开启root账号 [3]、Raspberry Pi树莓派无线网卡配置[多重方法备选] [4]、NextCloud论坛","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/categories/树莓派/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/tags/树莓派/"}]},{"title":"Mac使用Android代理翻墙记录","slug":"Mac使用Android代理翻墙记录","date":"2018-05-17T15:29:09.000Z","updated":"2018-10-26T05:51:01.374Z","comments":true,"path":"2018/05/17/Mac使用Android代理翻墙记录/","link":"","permalink":"https://tanjunze.github.io/2018/05/17/Mac使用Android代理翻墙记录/","excerpt":"1、下载Proxy Server代理软件2、创建一个代理服务（Proxy Server）","text":"1、下载Proxy Server代理软件2、创建一个代理服务（Proxy Server） 3、设置服务名和端口并返回后点击Start按钮启动服务 4、打开FireFox浏览器并配置网络代理 5、设置启动代理服务手机的Ip和上面填写端口 到此 FireFox 可以使用手机的代理服务，如果手机已经翻墙了，那么FireFox就可以实现翻墙。 同样可以为电脑设置代理配置，实现全局代理。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://tanjunze.github.io/categories/杂记/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://tanjunze.github.io/tags/代理/"}]},{"title":"机器学习资料整理","slug":"机器学习资料整理","date":"2018-04-27T15:36:40.000Z","updated":"2018-10-26T05:52:14.126Z","comments":true,"path":"2018/04/27/机器学习资料整理/","link":"","permalink":"https://tanjunze.github.io/2018/04/27/机器学习资料整理/","excerpt":"我的机器学习资料，为了方便查询同步到笔记中。 机器学习资料文档资料 深度学习资料-Github 神经网络和深度学习•Michael Nielsen 神经网络和深度学习•Michael Nielsen（翻译）","text":"我的机器学习资料，为了方便查询同步到笔记中。 机器学习资料文档资料 深度学习资料-Github 神经网络和深度学习•Michael Nielsen 神经网络和深度学习•Michael Nielsen（翻译） 深度学习•Bengio 深度学习•Bengio（翻译） Tensorflow官网-国内 Tensorflow社区-国内 深度学习资料整理1-国内 深度学习路线图 深度学习博文 深度学习Java框架 在线教育 Google深度学习-Udacity课程 Google机器学习速成课程 深度学习-Stanford-UFLDL 深度学习-Stanford-Tutorial 人工智能实践：Tensorflow笔记-慕课网 莫烦Python 工具 python jupyter notebook 框架 Tensorflow Tensorflow（极客学院-翻译） TensorLayer-中文 TensorLayer scikit-learn scikit-learn 翻译 caffe 或 caffe2 Keras keras 翻译 theano … 其他文档 Deepmind 积卷神经网络-斯坦福 Siraj Raval-Gitub-Youtube CS231n课程-积卷网络 CS231n课程-积卷网络-中文翻译 深度学习-开源项目 音频合成-Merlin 音频合成-Wavenet 深度学习-Udacity-Code 无人驾驶-BehavioralCloning) 无人驾驶-udacity-sim 无人驾驶-CSDN博文 机器学习数据集 机器学习数据集1-知乎提问 机器学习数据集2-知乎博文","categories":[{"name":"资料","slug":"资料","permalink":"https://tanjunze.github.io/categories/资料/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://tanjunze.github.io/tags/机器学习/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://tanjunze.github.io/tags/TensorFlow/"}]},{"title":"Dart 之旅","slug":"Dart之旅","date":"2018-03-21T20:10:13.000Z","updated":"2019-02-26T07:18:18.066Z","comments":true,"path":"2018/03/22/Dart之旅/","link":"","permalink":"https://tanjunze.github.io/2018/03/22/Dart之旅/","excerpt":"","text":"dartpad 特性 所有的变量引用都是对象，每个对象都是一个类的实例。在Dart 中甚至 数字（numbers）、方法（functions）和null都是对象。所有对象都继承Object类。 尽管Dart 是强类型语言，但是类型声明是可选的，因为Dart可以推断类型。如果要明确说明不需要任何类型， 则使用特殊类型dynamic。 Dart 支持泛型，例如List 或List。 Dart 支持顶级方法（如main()），静态方法，实例方法和方法内方法（嵌套函数和本地函数）。 Dart 支持顶级变量，以及类中定义变量（静态变量和实例变量）。实例变量有时称为字段和属性。 与Java不同的是，Dart 中没有public,private,protected关键字，如果标识符已（_）开头，则其是私有的。 标识符可以以字母或下划线（_）开头，后跟这些字符加数字的任意组合。 Dart有两个表达式（具有运行时值）和 语句（不具有）。例如，条件表达式 condition ? expr1 : expr2的值为expr1或expr2。将其与if-else语句进行比较，该语句没有任何值。语句通常包含一个或多个表达式，但表达式不能直接包含语句。 Dart工具可以报告两种问题：警告和错误。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误会阻止代码执行; 运行时错误导致 代码执行时引发异常。 变量12var name='Bob';dynamic name = 'Bob' ; 默认值未初始化的变量默认为null。 1int lineCount ; assert （lineCount == null ）; final 和 const如果不打算修改一个变量，使用final或const,final 修饰的变量只能赋值一次；一个const变量是编译时常量。（const变量同时也是final变量。）顶级的final 变量或类中的final变量在第一次使用时初始化。 12345678910final name = 'Bob'; final String nickname = 'Bobby';const bar = 1000000；const double atm = 1.01325 * bar;var foo = const [];final bar = const [];const baz = []; // 等价于`const []`foo = [1, 2, 3]; // const []baz = [42]; // 错误 不能赋值 内置类型number123456789101112131415161718192021222324252627282930// int 类型var x = 1 ;var hex = 0xDEADBEEF ; // double 类型var y = 1.1 ; var exponents = 1.42e5 ; double z = 1 ; //相当于double z = 1.0。 // 类型转换// String -&gt; intvar one = int.parse('1');assert(one == 1);// String -&gt; doublevar onePointOne = double.parse('1.1');assert(onePointOne == 1.1);// int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == '1');// double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == '3.14');assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001assert((3 | 4) == 7); // 0011 | 0100 == 0111const msPerSecond = 1000;const secondsUntilRetry = 5;const msUntilRetry = secondsUntilRetry * msPerSecond; StringDart String 是UTF-16编码，可以使用&#39;或&quot; 1234var s1 = 'Single quotes work well for string literals.';var s2 = \"Double quotes work just as well.\";var s3 = 'It\\'s easy to escape the string delimiter.';var s4 = \"It's even easier to use the other delimiter.\"; 字符串拼接 1234567891011121314151617181920212223242526272829303132333435var s = 'string interpolation';assert('Dart has $s, which is very handy.' == 'Dart has string interpolation, ' + 'which is very handy.'); // trueassert('That deserves all caps. ' + '$&#123;s.toUpperCase()&#125; is very handy!' == 'That deserves all caps. ' + 'STRING INTERPOLATION is very handy!'); // truevar s1 = 'String ' 'concatenation' \" works even over line breaks.\";assert(s1 == 'String concatenation works even over ' 'line breaks.'); // truevar s2 = 'The + operator ' + 'works, as well.';assert(s2 == 'The + operator works, as well.'); // truevar s = r'In a raw string, not even \\n gets special treatment.';// These work in a const string.const aConstNum = 0;const aConstBool = true;const aConstString = 'a constant string';// These do NOT work in a const string.var aNum = 0;var aBool = true;var aString = 'a string';const aConstList = [1, 2, 3];const validConstString = '$aConstNum $aConstBool $aConstString';// const invalidConstString = '$aNum $aBool $aString $aConstList'; Booleans123456789101112131415// Check for an empty string.var fullName = '';assert(fullName.isEmpty);// Check for zero.var hitPoints = 0;assert(hitPoints &lt;= 0);// Check for null.var unicorn;assert(unicorn == null);// Check for NaN.var iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); List12345678910var list = [1, 2, 3];var list = [1, 2, 3];assert(list.length == 3);assert(list[1] == 2);list[1] = 1;assert(list[1] == 1);var constantList = const [1, 2, 3];// constantList[1] = 1; // Uncommenting this causes an error. Maps12345678910111213141516171819202122232425262728293031323334353637383940414243var gifts = &#123; // Key: Value 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings'&#125;;var nobleGases = &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;var gifts = Map();gifts['first'] = 'partridge';gifts['second'] = 'turtledoves';gifts['fifth'] = 'golden rings';var nobleGases = Map();nobleGases[2] = 'helium';nobleGases[10] = 'neon';nobleGases[18] = 'argon';var gifts = &#123;'first': 'partridge'&#125;;gifts['fourth'] = 'calling birds'; // Add a key-value pairvar gifts = &#123;'first': 'partridge'&#125;;assert(gifts['first'] == 'partridge');var gifts = &#123;'first': 'partridge'&#125;;assert(gifts['fifth'] == null);var gifts = &#123;'first': 'partridge'&#125;;gifts['fourth'] = 'calling birds';assert(gifts.length == 2);// truefinal constantMap = const &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;// constantMap[2] = 'Helium'; // Uncommenting this causes an error. Runes表达Unicode代码的常用方法是 \\uXXXX，其中XXXX是4位十六进制值。例如，心脏（♥）是\\u2665。要是多于或少于4个十六进制数字，将值放在大括号中。例如，笑表情符号（😆）是\\u{1f600}。 1234567891011121314main() &#123; var clapping = '\\u&#123;1f44f&#125;'; print(clapping); print(clapping.codeUnits); print(clapping.runes.toList()); // 👏 //[55357, 56399] //[128079] Runes input = new Runes( '\\u2665 \\u&#123;1f605&#125; \\u&#123;1f60e&#125; \\u&#123;1f47b&#125; \\u&#123;1f596&#125; \\u&#123;1f44d&#125;'); print(new String.fromCharCodes(input)); // ♥ 😅 😎 👻 🖖 👍&#125; 方法1234bool isNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125;bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null; 可选参数可选参数可以是命名参数或者基于位置的参数，但是这两种参数不能同时当做可选参数。 Optional named parameters（可选命名参数）调用函数时，可以使用指定命名参数 。例如：*paramName*: *value* 1enableFlags （bold ：true ，hidden ：false ）; 定义函数时，用于 {param1, param2, …}指定命名参数。 1void enableFlags(&#123;bool bold, bool hidden&#125;) &#123;...&#125; Optional positional parameters（可选位置参数）把一些方法的参数放到 [] 中就变成可选 位置参数了： 1234567891011String say(String from, String msg, [String device]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; return result;&#125;assert(say('Bob', 'Howdy') == 'Bob says Howdy'); //trueassert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal');// true Default parameter values（默认参数值）12345678910111213141516171819202122232425262728293031/// Sets the [bold] and [hidden] flags ...void enableFlags(&#123;bool bold = false, bool hidden = false&#125;) &#123;...&#125;// bold will be true; hidden will be false.enableFlags(bold: true);String say(String from, String msg, [String device = 'carrier pigeon', String mood]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; if (mood != null) &#123; result = '$result (in a $mood mood)'; &#125; return result;&#125;assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');void doStuff( &#123;List&lt;int&gt; list = const [1, 2, 3], Map&lt;String, String&gt; gifts = const &#123; 'first': 'paper', 'second': 'cotton', 'third': 'leather' &#125;&#125;) &#123; print('list: $list'); print('gifts: $gifts');&#125;","categories":[{"name":"Dart","slug":"Dart","permalink":"https://tanjunze.github.io/categories/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://tanjunze.github.io/tags/Dart/"}]},{"title":"Android AIDL 使用","slug":"Android AIDL 一  基本使用 ","date":"2018-02-25T21:13:43.000Z","updated":"2019-02-26T07:22:00.361Z","comments":true,"path":"2018/02/26/Android AIDL 一  基本使用 /","link":"","permalink":"https://tanjunze.github.io/2018/02/26/Android AIDL 一  基本使用 /","excerpt":"","text":"Android AIDLAIDL：Android Interface Definition Language 。用于IPC （Inter-Process Communication，进程间通信），如 多应用间的通信，应用中存在多进程间的通信等场景。 只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口 一、定义AIDL接口1、创建 .aidl 文件在src 文件夹内创建IRemoteService.aidl 文件，如下。编译工程，此时会在创建相同名称的 IRemoteService.java文件。 12345678910111213141516// IRemoteService.aidlpackage com.example.android;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService &#123; /** Request the process ID of this service, to do evil things with it. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 2、实现.aidl生成的.java接口123456789private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125;&#125;; 3、公开接口12345678910111213141516171819202122public class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125; &#125;;&#125; 二、通过IPC 传递对象IPC 中传递的对象需要实现 Parcelable 接口 ，例如 Rect.aidl 文件可创建一个可打包的 Rect 类： 12345package android.graphics;// Declare Rect so AIDL can find it and knows that it implements// the parcelable protocol.parcelable Rect; 1234567891011121314151617181920212223242526272829303132333435363738394041import android.os.Parcel;import android.os.Parcelable;public final class Rect implements Parcelable &#123; public int left; public int top; public int right; public int bottom; public static final Parcelable.Creator&lt;Rect&gt; CREATOR = newParcelable.Creator&lt;Rect&gt;() &#123; public Rect createFromParcel(Parcel in) &#123; return new Rect(in); &#125; public Rect[] newArray(int size) &#123; return new Rect[size]; &#125; &#125;; public Rect() &#123; &#125; private Rect(Parcel in) &#123; readFromParcel(in); &#125; public void writeToParcel(Parcel out) &#123; out.writeInt(left); out.writeInt(top); out.writeInt(right); out.writeInt(bottom); &#125; public void readFromParcel(Parcel in) &#123; left = in.readInt(); top = in.readInt(); right = in.readInt(); bottom = in.readInt(); &#125;&#125; 三、 调用 IPC 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public static class Binding extends Activity &#123; /** The primary interface we will be calling on the service. */ IRemoteService mService = null; /** Another interface we use on the service. */ ISecondary mSecondaryService = null; Button mKillButton; TextView mCallbackText; private boolean mIsBound; /** * Standard initialization of this activity. Set up the UI, then wait * for the user to poke it before doing anything. */ @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.remote_service_binding); // Watch for button clicks. Button button = (Button)findViewById(R.id.bind); button.setOnClickListener(mBindListener); button = (Button)findViewById(R.id.unbind); button.setOnClickListener(mUnbindListener); mKillButton = (Button)findViewById(R.id.kill); mKillButton.setOnClickListener(mKillListener); mKillButton.setEnabled(false); mCallbackText = (TextView)findViewById(R.id.callback); mCallbackText.setText(\"Not attached.\"); &#125; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the service object we can use to // interact with the service. We are communicating with our // service through an IDL interface, so get a client-side // representation of that from the raw service object. mService = IRemoteService.Stub.asInterface(service); mKillButton.setEnabled(true); mCallbackText.setText(\"Attached.\"); // We want to monitor the service for as long as we are // connected to it. try &#123; mService.registerCallback(mCallback); &#125; catch (RemoteException e) &#123; // In this case the service has crashed before we could even // do anything with it; we can count on soon being // disconnected (and then reconnected if it can be restarted) // so there is no need to do anything here. &#125; // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_connected, Toast.LENGTH_SHORT).show(); &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mKillButton.setEnabled(false); mCallbackText.setText(\"Disconnected.\"); // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_disconnected, Toast.LENGTH_SHORT).show(); &#125; &#125;; /** * Class for interacting with the secondary interface of the service. */ private ServiceConnection mSecondaryConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // Connecting to a secondary interface is the same as any // other interface. mSecondaryService = ISecondary.Stub.asInterface(service); mKillButton.setEnabled(true); &#125; public void onServiceDisconnected(ComponentName className) &#123; mSecondaryService = null; mKillButton.setEnabled(false); &#125; &#125;; private OnClickListener mBindListener = new OnClickListener() &#123; public void onClick(View v) &#123; // Establish a couple connections with the service, binding // by interface names. This allows other applications to be // installed that replace the remote service by implementing // the same interface. Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); intent.setAction(ISecondary.class.getName()); bindService(intent, mSecondaryConnection, Context.BIND_AUTO_CREATE); mIsBound = true; mCallbackText.setText(\"Binding.\"); &#125; &#125;; private OnClickListener mUnbindListener = new OnClickListener() &#123; public void onClick(View v) &#123; if (mIsBound) &#123; // If we have received the service, and hence registered with // it, then now is the time to unregister. if (mService != null) &#123; try &#123; mService.unregisterCallback(mCallback); &#125; catch (RemoteException e) &#123; // There is nothing special we need to do if the service // has crashed. &#125; &#125; // Detach our existing connection. unbindService(mConnection); unbindService(mSecondaryConnection); mKillButton.setEnabled(false); mIsBound = false; mCallbackText.setText(\"Unbinding.\"); &#125; &#125; &#125;; private OnClickListener mKillListener = new OnClickListener() &#123; public void onClick(View v) &#123; // To kill the process hosting our service, we need to know its // PID. Conveniently our service has a call that will return // to us that information. if (mSecondaryService != null) &#123; try &#123; int pid = mSecondaryService.getPid(); // Note that, though this API allows us to request to // kill any process based on its PID, the kernel will // still impose standard restrictions on which PIDs you // are actually able to kill. Typically this means only // the process running your application and any additional // processes created by that app as shown here; packages // sharing a common UID will also be able to kill each // other's processes. Process.killProcess(pid); mCallbackText.setText(\"Killed service process.\"); &#125; catch (RemoteException ex) &#123; // Recover gracefully from the process hosting the // server dying. // Just for purposes of the sample, put up a notification. Toast.makeText(Binding.this, R.string.remote_call_failed, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125;; // ---------------------------------------------------------------------- // Code showing how to deal with callbacks. // ---------------------------------------------------------------------- /** * This implementation is used to receive callbacks from the remote * service. */ private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() &#123; /** * This is called by the remote service regularly to tell us about * new values. Note that IPC calls are dispatched through a thread * pool running in each process, so the code executing here will * NOT be running in our main thread like most other things -- so, * to update the UI, we need to use a Handler to hop over there. */ public void valueChanged(int value) &#123; mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0)); &#125; &#125;; private static final int BUMP_MSG = 1; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BUMP_MSG: mCallbackText.setText(\"Received from service: \" + msg.arg1); break; default: super.handleMessage(msg); &#125; &#125; &#125;;&#125; 参考： [1]、Android AIDL","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Java 多线程","slug":"Java多线程","date":"2018-02-09T23:38:33.000Z","updated":"2019-03-26T07:26:58.149Z","comments":true,"path":"2018/02/10/Java多线程/","link":"","permalink":"https://tanjunze.github.io/2018/02/10/Java多线程/","excerpt":"","text":"Java 线程进程：CPU资源的最小分配单元 线程：CPU调度的最小单元 一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束 线程的生命周期 新建状态 使用使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态 一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取synchronized同步锁失败（被其他线程占用） 其他阻塞：通过调度线程的sleep()或join()发出了I/O请求时，线程就会进入到阻塞状态。当sleep()阻塞超时，join()等待线程终止或超时，或者I/O处理完毕，线程重新转入就绪状态。 结束状态（死亡状态） 一个运行状态的线程完成任务或其他终止条件发生时，该线程就会切换到终止状态 线程的优先级Java 线程优先级使用 1 ~ 10 的整数表示： 最低优先级 1：Thread.MIN_PRIORITY 最高优先级 10：Thread.MAX_PRIORITY 普通优先级 5：Thread.NORM_PRIORITY 创建线程Java 提供了三种创建线程的方法： 实现Runnable接口 12345678910111213class RunnableThread implements Runnable &#123; // ··· public void start() &#123; if (t == null) &#123; t = new Thread(this, threadName); t.start(); &#125; &#125;&#125; public static void main(String args[]) &#123; RunnableThread rthread = new RunnableThread( \"Thread-1\"); rthread.start();&#125; 继承Thread类本身 1234567891011class ThreadTest extends Thread&#123; @Override public void run() &#123; super.run(); // ···· &#125;&#125;public static void main(String args[]) &#123; ThreadTest tTest = new ThreadTest( \"Thread-1\"); tTest.start();&#125; 通过Callable和Future创建线程 1234567891011121314151617181920class Task implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; // ··· return sum; &#125;&#125;public static void main(String args[]) &#123; ExecutorService executor = Executors.newCachedThreadPool(); Task task = new Task(); Future&lt;Integer&gt; result = executor.submit(task); executor.shutdown(); try &#123; System.out.println(\"task运行结果\"+result.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; 多线程使用多个线程来执行并行任务，当程序使用多线程时会产生一些的问题，如多线程频繁创建销毁产生的性能开销，当多个线程争夺同一个资源产生并发问题（死锁问题）等。 线程池用于解决大量线程频繁创建销毁带来的性能开销，当一个线程任务完成时，在线程池中复用当前线程并执行新的任务。 优点 减少频发创建销毁线程带来的线程开销。 复用线程可以提高响应速度 提高线程的可管理性 线程是一种稀缺的资源，若不加以限制，不仅占用大量的资源，而且会影响系统的稳定性。线程池可以对线程的创建于停止，线程数量等因素加以控制，使得线程在一种可控的范围内运行。 组成 工作线程 工作线程是一组已经处于运行中的线程，它们不断地向阻塞队列中领取任务执行。 阻塞队列 阻塞队列用于存储工作线程来不及处理的任务。当线程都在执行任务时，到来的新任务就只能暂时在阻塞队列中存储。 创建线程池 java中通过Executors提供四种线程池 newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，无可回收，则新建线程。 123456ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); cachedThreadPool.execute(new Runnable() &#123; public void run() &#123; //··· &#125; &#125;); newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 12//指定线程池大小为3ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); newScheduledThreadPool 创建定长的线程池，支持定时及周期性任务。 123456ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() &#123; public void run() &#123; System.out.println(\"delay 1 seconds, and excute every 3 seconds\"); &#125; &#125;, 1, 3, TimeUnit.SECONDS); //延迟1秒后每3秒执行一次 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定的顺序执行。 123456ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); singleThreadExecutor.execute(new Runnable() &#123; public void run() &#123; //··· &#125; &#125;); 虽然java中提供了4中创建线程池的方式，但不推荐在开发中使用，因为ExecutorService 默认使用了最大长度为Integer.MAX_VALUE的LinkedBlockingQueue链表阻塞队列在Adroid开发中可能产生OOM。详细原因请移步Java中线程池，你真的会用吗？，推荐使用ThreadPoolExecutor 1ExecutorService executor = new ThreadPoolExecutor(10, 10,60L, TimeUnit.SECONDS, new ArrayBlockingQueue(10)); 线程安全什么是线程安全？在多线程执行的过程中虽然可以提高任务的处理，系统的响应速度也产生了线程之间的安全问题，如多线程之间可能抢占资源，导致了一些错误（卖票问题）。解决多线程下产生的问题就是线程安全。 产生线程安全问题的原因 首先在JVM中有2内存模型 主内存 存放类的实例，静态数据等变量，是线程共享的。 工作内存 存放从主内存中拷贝的变量，每个线程都有自己的工作内存。 java中线程不能直接操作主内存中的变量，只能将主内存中的变量拷贝至当前线程所在的工作内存中进行操作。线程间又不共享内存所以不能直接通信，需要接借助主内存进行线程间的通信。 工作内存与主内存的4中操作 read:读取主内存的变量,并将其传送到工作内存 load:把read操作从主内存得到的变量值放入到工作内存的拷贝中 store:把工作内存中的一个变量值传送到主内存当中,以便用于后面的write操作 write:把store操作从工作内存中得到的变量的值放入主内存的变量中. 由上可以了解到，当多个工作线程同时访问同一个变量时，每个线程都会将这个变量中拷贝到自己的工作内存进行修改操作再加载到主内存中又无法告知其他线程自己在操作（内存不可见性）。这种情况下，同一时刻一个变量可能会在同一个基础上进行了修改（共享变量 ‘10’，线程1减一同时线程2减一，可能造成变量变为‘9’，而实际应该为‘8’），从而产生一些同步问题。 实现线程安全的方式 由上可以了解到线程产生的安全问题的原因，解决这个问题需要共享变量在同一个时刻只能有一个线程访问的机制，而java中就有这种机——锁机制。java内存模型中定义了2个原子操作 lock:将主内存的变量标识为一条线程独占状态 unlock:解除主内存中变量的线程独占状态 而在java代码层面上每个对象都有一个内置锁。锁的修饰体现为有 synchronized和volitate关键字。 synchronized synchronized用来解决多线程同步问题，根据修饰的位置不同分为： 同步代码块 有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。 12345 public void methodName() &#123; synchronized (obj) &#123; // 同步代码块 &#125;&#125; 同步方法 有synchronized关键字修饰的方法。内置锁会保护整个方法。 123//同步方法public synchronized void methodName() &#123;&#125; 两者的区别： 修饰的位置不同。 作用范围不同 粒度大小不同。 volitate 使用 volitate 修饰变量 1private volatile int account = 100; ReentrantLock 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 其他线程同步方式 final 修饰的变量不可写所以 final 也可以实现变量的同步。 ThreadLocal ​ a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。​ b.前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式 扩展乐观锁、CAS等 参考： Java 多线程编程 深入浅出Java线程池 Java四种线程池的使用 Java并发编程：线程池的使用 深入理解java线程池—ThreadPoolExecutor 不一样的视角:从JVM内存模型谈线程安全 啃碎并发（五）：Java线程安全特性与问题 Java 中的多线程你只要看这一篇就够了 理解Java中的ThreadLocal Java CAS 原理剖析 全面理解Java内存模型(JMM)及volatile关键字","categories":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://tanjunze.github.io/tags/java/"}]},{"title":"Android ContentProvider","slug":"Android ContentProvider","date":"2018-01-25T23:27:04.000Z","updated":"2019-02-26T07:21:33.499Z","comments":true,"path":"2018/01/26/Android ContentProvider/","link":"","permalink":"https://tanjunze.github.io/2018/01/26/Android ContentProvider/","excerpt":"","text":"Android ContentProviderContentProvider（内容提供者）作为Android 四大组件之一主要用于为为其他应用提供复杂的数据或文件。 内容 URI是ContentProvider 的唯一表示,app 根据您 内容uri 查询操作数据。内容uri的结构如下： 1content://authority/tablename/id 标识 说明 content ContentProvider 前缀标识 authority 授权：指定内容提供者的名称，如：com.hello.provider tablename 需要访问数据的名称，一般为数据库表名 如：user id 数据表下 id 表示的行,如：1 示例：content://com.hello.provider/user/1 访问 com.hello.provider数据user 表中1表示的行。 内容url 的通配符 ​ *：匹配由任意长度的任何有效字符组成的字符串 ​ #：匹配由任意长度的数字字符组成的字符串 创建内容提供者1、实现ContentProvider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class BookProvider extends ContentProvider &#123; private static final String TAG = \"BookProvider\"; public static final String AUTHORITY = \"com.ryg.chapter_2.book.provider\"; public static final Uri BOOK_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/book\"); public static final Uri USER_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/user\"); public static final int BOOK_URI_CODE = 0; public static final int USER_URI_CODE = 1; private static final UriMatcher sUriMatcher = new UriMatcher( UriMatcher.NO_MATCH); static &#123; sUriMatcher.addURI(AUTHORITY, \"book\", BOOK_URI_CODE); sUriMatcher.addURI(AUTHORITY, \"user\", USER_URI_CODE); &#125; private Context mContext; private SQLiteDatabase mDb; @Override public boolean onCreate() &#123; Log.d(TAG, \"onCreate, current thread:\" + Thread.currentThread().getName()); mContext = getContext(); initProviderData(); return true; &#125; private void initProviderData() &#123; mDb = new DbOpenHelper(mContext).getWritableDatabase(); mDb.execSQL(\"delete from \" + DbOpenHelper.BOOK_TABLE_NAME); mDb.execSQL(\"delete from \" + DbOpenHelper.USER_TALBE_NAME); mDb.execSQL(\"insert into book values(3,'Android');\"); mDb.execSQL(\"insert into book values(4,'Ios');\"); mDb.execSQL(\"insert into book values(5,'Html5');\"); mDb.execSQL(\"insert into user values(1,'jake',1);\"); mDb.execSQL(\"insert into user values(2,'jasmine',0);\"); &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; Log.d(TAG, \"query, current thread:\" + Thread.currentThread().getName()); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; return mDb.query(table, projection, selection, selectionArgs, null, null, sortOrder, null); &#125; @Override public String getType(Uri uri) &#123; Log.d(TAG, \"getType\"); return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; Log.d(TAG, \"insert\"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; mDb.insert(table, null, values); mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; Log.d(TAG, \"delete\"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; int count = mDb.delete(table, selection, selectionArgs); if (count &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; Log.d(TAG, \"update\"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; int row = mDb.update(table, values, selection, selectionArgs); if (row &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return row; &#125; private String getTableName(Uri uri) &#123; String tableName = null; switch (sUriMatcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = DbOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = DbOpenHelper.USER_TALBE_NAME; break; default:break; &#125; return tableName; &#125;&#125; 注册 ContentProvider 1234&lt;provider android:name=\".provider.BookProvider\" android:authorities=\"com.ryg.chapter_2.book.provider\" &gt;&lt;/provider&gt; 2、调用ContentProvider12345678910111213141516171819202122232425262728293031323334public class ProviderActivity extends Activity &#123; private static final String TAG = \"ProviderActivity\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_provider); Uri bookUri = Uri.parse(\"content://com.ryg.chapter_2.book.provider/book\"); ContentValues values = new ContentValues(); values.put(\"_id\", 6); values.put(\"name\", \"程序设计的艺术\"); getContentResolver().insert(bookUri, values); Cursor bookCursor = getContentResolver().query(bookUri, new String[]&#123;\"_id\", \"name\"&#125;, null, null, null); while (bookCursor.moveToNext()) &#123; Book book = new Book(); book.bookId = bookCursor.getInt(0); book.bookName = bookCursor.getString(1); Log.d(TAG, \"query book:\" + book.toString()); &#125; bookCursor.close(); Uri userUri = Uri.parse(\"content://com.ryg.chapter_2.book.provider/user\"); Cursor userCursor = getContentResolver().query(userUri, new String[]&#123;\"_id\", \"name\", \"sex\"&#125;, null, null, null); while (userCursor.moveToNext()) &#123; User user = new User(); user.userId = userCursor.getInt(0); user.userName = userCursor.getString(1); user.isMale = userCursor.getInt(2) == 1; Log.d(TAG, \"query user:\" + user.toString()); &#125; userCursor.close(); &#125;&#125; 3、添加自定义权限ContentProvider 可以自定义权限来限制 数据共享的应用， 自定义权限：https://developer.android.com/guide/topics/manifest/permission-element.html 参考： [1]、Android ContentProvider [2]、Android Permission [3]、《Android开发艺术探索》","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Android FragmentPageAdapter 与 FragmentStatePageAdapter","slug":"FragmentPageAdapter","date":"2017-12-04T22:30:59.000Z","updated":"2019-02-26T06:32:10.348Z","comments":true,"path":"2017/12/05/FragmentPageAdapter/","link":"","permalink":"https://tanjunze.github.io/2017/12/05/FragmentPageAdapter/","excerpt":"","text":"FragmentPageAdapter 与 FragmentStatePageAdapter在项目中需要动态更新Tab，于是对于选择FragmentPageAdapter和FragmentStatePageAdapter有点困惑。几经周转总算理解了，这里记录一下。当然有问题是的时候还是看官方文档比较详细。 FragmentPageAdapter官网：https://developer.android.com/reference/android/support/v4/app/FragmentPagerAdapter.html 文档中描述了FragmentPageAdapter中每一个Fragment都将保存在内存，所以FragmentPagerAdapter适合那些相数量相对较少，静态的页面。对于存在多个fragment的情况，一般推荐使用FragmentStatePagerAdapter。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class FragmentPagerSupport extends FragmentActivity &#123; static final int NUM_ITEMS = 10; MyAdapter mAdapter; ViewPager mPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.fragment_pager); mAdapter = new MyAdapter(getSupportFragmentManager()); mPager = (ViewPager)findViewById(R.id.pager); mPager.setAdapter(mAdapter); // Watch for button clicks. Button button = (Button)findViewById(R.id.goto_first); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mPager.setCurrentItem(0); &#125; &#125;); button = (Button)findViewById(R.id.goto_last); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mPager.setCurrentItem(NUM_ITEMS-1); &#125; &#125;); &#125; public static class MyAdapter extends FragmentPagerAdapter &#123; public MyAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public int getCount() &#123; return NUM_ITEMS; &#125; @Override public Fragment getItem(int position) &#123; return ArrayListFragment.newInstance(position); &#125; &#125; public static class ArrayListFragment extends ListFragment &#123; int mNum; /** * Create a new instance of CountingFragment, providing \"num\" * as an argument. */ static ArrayListFragment newInstance(int num) &#123; ArrayListFragment f = new ArrayListFragment(); // Supply num input as an argument. Bundle args = new Bundle(); args.putInt(\"num\", num); f.setArguments(args); return f; &#125; /** * When creating, retrieve this instance's number from its arguments. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mNum = getArguments() != null ? getArguments().getInt(\"num\") : 1; &#125; /** * The Fragment's UI is just a simple text view showing its * instance number. */ @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_pager_list, container, false); View tv = v.findViewById(R.id.text); ((TextView)tv).setText(\"Fragment #\" + mNum); return v; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), android.R.layout.simple_list_item_1, Cheeses.sCheeseStrings)); &#125; @Override public void onListItemClick(ListView l, View v, int position, long id) &#123; Log.i(\"FragmentList\", \"Item clicked: \" + id); &#125; &#125;&#125; R.layout.fragment_pager 1234567891011121314151617181920212223242526&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:padding=\"4dip\" android:gravity=\"center_horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/pager\" android:layout_width=\"match_parent\" android:layout_height=\"0px\" android:layout_weight=\"1\"&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;LinearLayout android:orientation=\"horizontal\" android:gravity=\"center\" android:measureWithLargestChild=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"0\"&gt; &lt;Button android:id=\"@+id/goto_first\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/first\"&gt; &lt;/Button&gt; &lt;Button android:id=\"@+id/goto_last\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/last\"&gt; &lt;/Button&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; R.layout.fragment_pager_list 123456789101112131415161718192021222324252627282930313233343536&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@android:drawable/gallery_thumb\"&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_vertical|center_horizontal\" android:textAppearance=\"?android:attr/textAppearanceMedium\" android:text=\"@string/hello_world\"/&gt; &lt;!-- The frame layout is here since we will be showing either the empty view or the list view. --&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"0dip\" android:layout_weight=\"1\" &gt; &lt;!-- Here is the list. Since we are using a ListActivity, we have to call it \"@android:id/list\" so ListActivity will find it --&gt; &lt;ListView android:id=\"@android:id/list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:drawSelectorOnTop=\"false\"/&gt; &lt;!-- Here is the view to show if the list is emtpy --&gt; &lt;TextView android:id=\"@android:id/empty\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:textAppearance=\"?android:attr/textAppearanceMedium\" android:text=\"No items.\"/&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; FragmentStatePageAdapter官网：https://developer.android.com/reference/android/support/v4/app/FragmentPagerAdapter.html FragmentStatePageAdapter 在适合像listView大量page的场景。当page不显示的时候fragment可能被销毁，此时fragment的状态会保存起来，相比FragmentPageAdapter占用内存较少。但是在 page 切换时fragment 再次创建会产生额外的开销。 123456789101112131415public static class MyAdapter extends FragmentStatePagerAdapter &#123; public MyAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public int getCount() &#123; return NUM_ITEMS; &#125; @Override public Fragment getItem(int position) &#123; return ArrayListFragment.newInstance(position); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Android Handle 消息机制","slug":"Android handle 消息机制","date":"2017-12-01T21:00:54.000Z","updated":"2019-03-13T14:14:12.266Z","comments":true,"path":"2017/12/02/Android handle 消息机制/","link":"","permalink":"https://tanjunze.github.io/2017/12/02/Android handle 消息机制/","excerpt":"","text":"Android Handle 消息机制handle 消息机制是Android 重要的组成部分，首先我们需要的理解的是Android为什么需要 handle 机制。开发Android的都得知道 Android有主线程之分（UI 线程），主线程中每16ms接收到Android系统的同步信号来更新UI 视图。如果在主线程中进行耗时操作会阻塞线性会造成ANR（无响应异常）。如果在子线程中进行耗时操作，当子线程任务完成时，无法直接调用主线程中UI 组件（主线程不是线程安全的，子线直接调用主线程中的UI 组件会产生不可预期的错误，如死锁等，如果给主线程加锁会造成UI 组件的复杂性并且阻塞了部分操作的执行）。基于以上的理由Android 设计了Handle 机制来确保当子线程执行完耗时操作时能够安全的更新主线程中的UI 视图（也可以确保不同线程之间的安全通信）。到这里我们能够理解 handle 机制 机制存在的理由了，下面我们继续组成、使用及原理。 如上图，Handle 中有三个重要的组成部分：handle，Loop，MessageQueue。 Handle在Handle主要承担着发送Message 到 MessageQueue队列中和和接收处理 Loop 分发过来的 Message。 如下代码 1234567891011121314151617181920212223242526public class HandleExample &#123; Handler mHandler; public static final int HANDLE_WHAT_1 = 10; public void HandleExample() &#123; mHandler = new Handler(Looper.getMainLooper()) &#123; // 接收 Loop 分发的 Message @Override public void handleMessage(Message message) &#123; switch (message.what) &#123; case HANDLE_WHAT_1: break; default: break; &#125; &#125; &#125;; Message message = new Message(); message.what = HANDLE_WHAT_1; message.arg1 = 1; message.arg2 = 2; message.obj = \"handle test\"; // 发送 消息 mHandler.sendMessage(message); &#125;&#125; 在源代码中 handle 通过 send***方法调用MessageQueue的queue.enqueueMessage向 MessageQueue插入一条Message 1234567891011121314151617181920// 源码 Handler.java public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 在Loop调用 MessageQueue中的 getNextMessage 方法 获取 Message的handle 引用 通过 dispatchMessage分发Handle 中处理。 12345678910111213141516// 源码 while (SystemClock.uptimeMillis() &lt; end) &#123; boolean conditionsMet = true; // 省略部分代码 if (conditionsMet) &#123; QueueState queueState = queueInterrogator.determineQueueState(); if (queueState == QueueState.EMPTY || queueState == QueueState.TASK_DUE_LONG) &#123; return; &#125; &#125; Message message = queueInterrogator.getNextMessage(); message.getTarget().dispatchMessage(message); recycler.recycle(message); loopCount++; &#125; MessageQueue单链表结构，主要用于存储 Message, 插入方法enqueueMessage,出队方法 next , LoopLoop 主要是一个循环器，它不断的循环 MessageQueue 队列并取出 Message 交个 Handle处理。","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Android Service 二 组件间通信","slug":"Android Service 二 组件间通信","date":"2017-11-13T22:35:02.000Z","updated":"2019-02-26T07:20:25.383Z","comments":true,"path":"2017/11/14/Android Service 二 组件间通信/","link":"","permalink":"https://tanjunze.github.io/2017/11/14/Android Service 二 组件间通信/","excerpt":"","text":"Android Service 通信Android 中 Service 通信需要使用 bindService启动方式，但是startService启动方式 也可以与组件间进行通信。这里总结 Service 通信方式。 startService1、使用广播通信不推荐此种方式 广播发送： 1234Intent intent = new Intent();intent.putExtra(\"paramkey1\",\"params1\");intent.setAction(RECEIVER_ACTION); LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent); 广播接收： 12345private BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // todo&#125; 2、EventBus 通信eventbus：https://github.com/greenrobot/EventBus 发送消息： 12345678910111213141516@Overridepublic void onStart() &#123; super.onStart(); EventBus.getDefault().register(this);&#125;@Overridepublic void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this);&#125;public void sendComponentMessage()&#123; // 发送消息 EventBus.getDefault().post(new MessageEvent());&#125; 接收消息： 1234@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(MessageEvent event) &#123; Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();&#125; bindService只有 Activity、服务和内容提供程序可以绑定到服务 — 无法从广播接收器绑定到服务。 1、 IBinder 通信 注：此方法只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效。 之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方法不执行任何跨进程编组。 1234567891011121314151617181920public class LocalService extends Service &#123; private final IBinder mBinder = new LocalBinder(); private final Random mGenerator = new Random(); public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class BindingActivity extends Activity &#123; LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, \"number: \" + num, Toast.LENGTH_SHORT).show(); &#125; &#125; /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We've bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;;&#125; 2、Messenger 通信 相对于 AIDL 当您需要执行 IPC 时，为您的接口使用 Messenger 要比使用 AIDL 实现它更加简单，因为 Messenger 会将所有服务调用排入队列，而纯粹的 AIDL 接口会同时向服务发送多个请求，服务随后必须应对多线程处理。 1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), \"hello!\", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), \"binding\", Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported 'what' value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 3、AIDL 通信Android AIDL 一 基本使用 参考： [1]、android 绑定服务","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Frp内网穿透笔记","slug":"Frp内网穿透笔记","date":"2017-11-01T23:50:34.000Z","updated":"2019-02-26T06:31:48.333Z","comments":true,"path":"2017/11/02/Frp内网穿透笔记/","link":"","permalink":"https://tanjunze.github.io/2017/11/02/Frp内网穿透笔记/","excerpt":"https://github.com/fatedier/frp/issues/176","text":"https://github.com/fatedier/frp/issues/176","categories":[{"name":"杂记","slug":"杂记","permalink":"https://tanjunze.github.io/categories/杂记/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://tanjunze.github.io/tags/其他/"}]},{"title":"Hexo/GitHub Pages搭建个人博客","slug":"Hexo搭建个人博客","date":"2017-10-05T11:06:23.000Z","updated":"2019-02-26T06:31:18.373Z","comments":true,"path":"2017/10/05/Hexo搭建个人博客/","link":"","permalink":"https://tanjunze.github.io/2017/10/05/Hexo搭建个人博客/","excerpt":"前言好久没有在github pages 中更新笔记了，刚把旧的github仓库重新整理了。在此记录一下，日后逐渐将旧笔记往这里迁移。","text":"前言好久没有在github pages 中更新笔记了，刚把旧的github仓库重新整理了。在此记录一下，日后逐渐将旧笔记往这里迁移。 1、配置环境Hexo官方文档: Hexo wiki \b首先安装: Node.js Git 再安装 Hexo1$ npm install -g hexo-cli \b到此Hexo安装完成，如果\b失败\b请参考官网，这里只记录简单流程。 2、搭建站点执行命令：123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 3\b、配置\b站点\b打开 folder/_config.yml 文件修改配置即可 4、\b启动服务1$ hexo server \b\b\b\b简写1$ hexo s 此时控制台中打印出 http://localhost:4000/ ,\b再\b使用\b\b\b\b浏览器打开你就可以\b看到Hello world页面了。 5、\b发布到github上参考：Hexo 部署 \b注意：首先\b你需要创建github账户，gtihub的仓库并push、pull\b\b仓库已验证\b你的github配置完成。 再\b创建一个仓库命名为&lt;\b你的用户名&gt;.github.io,如： tanjunze.github.io 打开本地&lt;folder&gt; Hexo工程安装 hexo-deployer-git123cd &lt;folder&gt;npm install hexo-deployer-git --save \b\b\b打开本地folder/_config.yml找到Deployment选项，并修改：其中将repo改为1git@github.com:&lt;你的账户名&gt;/&lt;你的账户名&gt;.github.io.git 执行1hexo deploy 如果push成功，打开https://&lt;\b你的用户名&gt;.github.io,例如： https://tanjunze.github.io/ 恭喜你成功搭建了在Hexo + Gtihub Pages 的个人免费站点了。 参考网址：http://www.cnblogs.com/zhcncn/p/4097881.html","categories":[{"name":"杂记","slug":"杂记","permalink":"https://tanjunze.github.io/categories/杂记/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://tanjunze.github.io/tags/其他/"}]},{"title":"Android Service 一","slug":"Android Service 一","date":"2017-10-01T23:03:43.000Z","updated":"2019-02-26T07:20:04.488Z","comments":true,"path":"2017/10/02/Android Service 一/","link":"","permalink":"https://tanjunze.github.io/2017/10/02/Android Service 一/","excerpt":"","text":"Android ServiceService 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。 一、Service 启动方式Service有2种启动方式： 1、startService12Intent intent = new Intent(this, HelloService.class);startService(intent); 当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。 2、bindSevice12Intent intent = new Intent(this, LocalService.class);bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE); 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从 onStartCommand() 返回的值必须是以下常量之一： 1、 START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 2、 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 3、 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 二、Service的生命周期 三、IntentServiceIntentService是 Service 的子类，它通过工作队列的形式处理任务。当任务完成时自动stopSelf() IntentService 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 四、前台服务前台服务(foreground service)可以简单理解为状态栏提供通知的服务，当一个服务为前台服务时，即使系统在在内存不足时，系统也不会考虑将其终止 创建前台服务需要在Service中提供状态栏通知，并调用startForeground())，例： 123456Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text),System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 五、扩展知识IntentServieJobIntentServicebinderServiceAsyncTaskHandlerThread参考： [1]、android services","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Android TheadLocal","slug":"Android TheadLoacl","date":"2017-09-24T23:23:07.000Z","updated":"2019-02-26T13:40:22.383Z","comments":true,"path":"2017/09/25/Android TheadLoacl/","link":"","permalink":"https://tanjunze.github.io/2017/09/25/Android TheadLoacl/","excerpt":"","text":"##","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Android 自定义View","slug":"Android自定义View","date":"2017-09-24T23:23:07.000Z","updated":"2019-03-13T14:21:27.593Z","comments":true,"path":"2017/09/25/Android自定义View/","link":"","permalink":"https://tanjunze.github.io/2017/09/25/Android自定义View/","excerpt":"","text":"Android 自定义View梳理一下自定义控件的基本流程和知识 自定义View实现View12345public class SimpleTextView extends View &#123; public SimpleTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;&#125; 自定义属性1、定义自定义属性在res/values文件夹下创建attrs.xml文件，在文件中使用&lt;declare-styleable&gt;声明自定义属性。 1234567&lt;resources&gt; &lt;declare-styleable name=\"SimpleTextView\"&gt; &lt;attr name=\"backgroundColor\" format=\"reference|color\" /&gt; &lt;attr name=\"text\" format=\"string\" /&gt; &lt;attr name=\"textSize\" format=\"dimension\" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 代码中&lt;declare-styleable&gt;对 SimpleTextView 的类声明属性。&lt;attr name=&quot;text&quot; format=&quot;string&quot; /&gt; 用来声明具体属性的名称和类型，如这里声明了string类型的text属性。支持声明的属性类型参考注。 2、使用自定义属性在代码中使用自定义属性的过程中需要使用 obtainStyledAttributes处理AttributeSet中的属性 12345678910111213141516 public SimpleTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray a = context.getTheme().obtainStyledAttributes( attrs, R.styleable.SimpleTextView, 0, 0); try &#123; text = a.getString(R.styleable.SimpleTextView_text); backgroundColor = a.getColor(R.styleable.SimpleTextView_backgroundColor, 0); int defaultTextSize = (int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics()); textSize = a.getDimensionPixelSize(R.styleable.SimpleTextView_textSize, defaultTextSize); &#125; finally &#123; a.recycle(); &#125;&#125; 这里需要注意的是TypedArray 使用完后一定要回收。如typedArray.recycle(); 绘制文本1234567891011121314private void initPaint() &#123; paint = new Paint(); paint.setTextSize(textSize); rect = new Rect(); paint.getTextBounds(text, 0, text.length(), rect);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; paint.setColor(backgroundColor); canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), paint); paint.setColor(Color.BLACK); canvas.drawText(text, getMeasuredWidth() / 2f - rect.width() / 2f, getMeasuredHeight() / 2f + rect.height() / 2f, paint); &#125; xml 文件中使用如下： 12345678910111213141516&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:custom=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"&gt; &lt;com.tanjz.demo.view.SimpleTextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" custom:backgroundColor=\"@color/seafoam\" custom:text=\"SimpleTextView\" custom:textSize=\"15sp\" /&gt;&lt;/LinearLayout&gt; 到这里就可以看到效果了，但是当android:layout_width=&quot;match_parent&quot;改为android:layout_width=&quot;wrap_content&quot;时SimpleTextView的宽没有改变。这种情况需要我们对控件进行测量并设置大小。 测量宽高View中有onMeasure,该方法是用来测量控件大小。我们可以使用该方法来实现View进行测量 1234567891011121314151617181920212223@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int width; int height; if (widthMode == MeasureSpec.EXACTLY) &#123; width = widthSize; &#125; else &#123; float textWidth = rect.width(); width = (int) (getPaddingLeft() + textWidth + getPaddingRight()); &#125; if (heightMode == MeasureSpec.EXACTLY) &#123; height = heightSize; &#125; else &#123; float textHeight = rect.height(); height = (int) (getPaddingTop() + textHeight + getPaddingBottom()); &#125; setMeasuredDimension(width, height);&#125; 在这里我们需要了解的是MeasureSpec.getMode，该方法提供给我们查询测量模式的类型，每种模式对View的大小要求不同。如： 测量模式 说明 AT_MOST 最大值模式：子布局限制在一个最大值内或为WARP_CONTENT EXACTLY 精确测量模式：明确的值或是MATCH_PARENT UNSPECIFIED 无约束模式：子控件可以是任意大小 上面代码中我们对 EXACTLY模式的以外的大小，通过计算的方式设置宽高。最后使用setMeasuredDimension(width, height)才能是宽高生效。 到这里当我们将SampleTextView的宽高改为wrap_content时，控件此时显示正常的大小。 添加属性和事件这里我们再实现一个点击后改变背景的效果。 12345678910111213141516private void initView() &#123; this.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; backgroundColor = randomColor(); invalidate(); //requestLayout(); &#125; &#125;); &#125; @ColorInt private int randomColor() &#123; Random random = new Random(); return 0xff000000 | random.nextInt(0x00ffffff); &#125; 这里注意的是我们需要invalidate()来刷新界面，它本质上是调用View的onDraw()绘制。 invalidate()与postInvalidate()区别在于invalidate()在主线程中调用，postInvalidate()在子线程中使用。 到这里自定View的基本知识就有所了解，下面我们再看看与自定义ViewGroup的区别及注意实现。 自定义ViewGroupViewGroup类型控件自定义和view类型的控件基本上一样的。这里需要注意的是onLayout,该方法用来对子控件进行定位操作。如我们看的线性布局效果就有它实现的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class CustomGroup extends ViewGroup &#123; public CustomGroup(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; /** * 定义子控件使用的布局参数。如 margin 属性，否则子控件没有margin属性。 */ @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int childsWidth = 0; int childsHeight = 0; int childsMarginLeft = 0; int childsMarginTop = 0; int childsMarginRight = 0; int childsMarginBottom = 0; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams(); measureChild(childView, widthMeasureSpec, heightMeasureSpec); childsHeight += childView.getMeasuredHeight(); childsWidth = Math.max(childsWidth, childView.getMeasuredWidth()); childsMarginLeft = Math.max(0, lp.leftMargin); childsMarginTop += lp.topMargin; childsMarginRight = Math.max(0, lp.rightMargin); childsMarginBottom += lp.bottomMargin; &#125; int viewGroupWidth = getPaddingLeft() + childsWidth + getPaddingRight() + childsMarginLeft + childsMarginRight; int viewGroupHeight = getPaddingTop() + childsHeight + getPaddingBottom() + childsMarginTop + childsMarginBottom; setMeasuredDimension(measureWidth(widthMeasureSpec, viewGroupWidth), measureHeight (heightMeasureSpec, viewGroupHeight)); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; if (changed) &#123; int childCount = getChildCount(); int mTop = getPaddingTop(); for (int j = 0; j &lt; childCount; j++) &#123; View childView = getChildAt(j); MarginLayoutParams params = (MarginLayoutParams) childView.getLayoutParams(); int mLeft = getPaddingLeft() + params.leftMargin; mTop += params.topMargin; childView.layout(mLeft, mTop, mLeft + childView.getMeasuredWidth(), mTop + childView.getMeasuredHeight()); mTop += (childView.getMeasuredHeight() + params.bottomMargin); &#125; &#125; &#125; private int measureWidth(int measureSpec, int viewGroupWidth) &#123; int resultWidth = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: resultWidth = specSize; break; case MeasureSpec.AT_MOST: resultWidth = Math.min(viewGroupWidth, specSize); break; case MeasureSpec.EXACTLY: resultWidth = specSize; break; default: break; &#125; return resultWidth; &#125; private int measureHeight(int measureSpec, int viewGroupHeight) &#123; int resultHeight = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: resultHeight = specSize; break; case MeasureSpec.AT_MOST: resultHeight = Math.min(viewGroupHeight, specSize); break; case MeasureSpec.EXACTLY: resultHeight = specSize; break; default: break; &#125; return resultHeight; &#125;&#125; 在onlayout中需要注意Android 的坐标体系 注自定义属性明细 1、布尔型 boolean 1&lt;attr name=\"showText\" format=\"boolean\" /&gt; 1app:showText = \"true\" 2、尺寸值 dimension 1&lt;attr name = \"pie_width\" format = \"dimension\" /&gt; 1app:pie_width = \"42dp\" 3、浮点值 float 1&lt;attr name = \"alpha\" format = \"float\" /&gt; 1app:alpha = \"1.0\" 4、整型值 integer 12345678&lt;declare-styleable name = \"AnimatedRotateDrawable\"&gt; &lt;attr name = \"visible\" /&gt; &lt;attr name = \"frameDuration\" format=\"integer\" /&gt; &lt;attr name = \"framesCount\" format=\"integer\" /&gt; &lt;attr name = \"pivotX\" /&gt; &lt;attr name = \"pivotY\" /&gt; &lt;attr name = \"drawable\" /&gt;&lt;/declare-styleable&gt; 1234567&lt;animated-rotate xmlns:android =\"http://schemas.android.com/apk/res/android\" android:drawable = \"@drawable/图片ID\" android:pivotX = \"50%\" android:pivotY = \"50%\" android:framesCount = \"12\" android:frameDuration = \"100\"/&gt; 5、字符串 string 1&lt;attr name = \"pieName\" format = \"string\" /&gt; 1android:pieName =\"this is a new pie\" 6、百分数 fraction 1&lt;attr name = \"pivotX\" format = \"fraction\" /&gt; 1android:pivotX = \"200%\" 7、枚举值 enum 1234&lt;attr name=\"orientation\"&gt; &lt;enum name=\"horizontal\" value=\"0\" /&gt; &lt;enum name=\"vertical\" value=\"1\" /&gt; &lt;/attr&gt; 1android:orientation = \"vertical\" 8、位或运算 flag 123456789101112&lt;attr name=\"windowSoftInputMode\"&gt; &lt;flag name = \"stateUnspecified\" value = \"0\" /&gt; &lt;flag name = \"stateUnchanged\" value = \"1\" /&gt; &lt;flag name = \"stateHidden\" value = \"2\" /&gt; &lt;flag name = \"stateAlwaysHidden\" value = \"3\" /&gt; &lt;flag name = \"stateVisible\" value = \"4\" /&gt; &lt;flag name = \"stateAlwaysVisible\" value = \"5\" /&gt; &lt;flag name = \"adjustUnspecified\" value = \"0x00\" /&gt; &lt;flag name = \"adjustResize\" value = \"0x10\" /&gt; &lt;flag name = \"adjustPan\" value = \"0x20\" /&gt; &lt;flag name = \"adjustNothing\" value = \"0x30\" /&gt; &lt;/attr&gt; 1android:windowSoftInputMode = \"stateUnspecified | stateUnchanged | stateHidden\" 9、引用资源ID reference 1&lt;attr name = \"background\" format = \"reference\" /&gt; 1android:background = \"@drawable/图片ID\" 10、颜色值 color 1&lt;attr name = \"textColor\" format = \"color\" /&gt; 1android:textColor = \"#00FF00\" 11、复合属性 1&lt;attr name = \"background\" format = \"reference|color\" /&gt; 12android:background = \"@drawable/图片ID\"android:textColor = \"#00FF00\" 参考： [1]、Android MeasureSpec [2]、Android 自定义View [3]、Android View的绘制流程","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Android手机搭建Linux环境","slug":"Android手机搭建Linux环境","date":"2017-09-24T23:23:07.000Z","updated":"2019-02-26T07:36:32.930Z","comments":true,"path":"2017/09/25/Android手机搭建Linux环境/","link":"","permalink":"https://tanjunze.github.io/2017/09/25/Android手机搭建Linux环境/","excerpt":"Termux介绍 Termux是Android，Chromebook和Fire OS的终端模拟器和Linux环境。","text":"Termux介绍 Termux是Android，Chromebook和Fire OS的终端模拟器和Linux环境。官网：https://wiki.termux.comgithub：https://github.com/termux/termux-app 1、配置Termux。1.1 升级 apt(否则无法安装软件)1apt update 1.2 安装openssh1apt intall openssh","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Activity的启动过程","slug":"Activity的启动过程","date":"2017-09-01T16:34:12.000Z","updated":"2019-03-22T03:48:12.768Z","comments":true,"path":"2017/09/02/Activity的启动过程/","link":"","permalink":"https://tanjunze.github.io/2017/09/02/Activity的启动过程/","excerpt":"","text":"Activity启动是一个复杂的过程，这里采用由简入繁，层层深入的方式来解密。 首先我们需要了解Activity的启动分为2中情况 Launch组件启动（桌面图标启动） 应用内startActivity启动 虽然启动方式分为2中，但是启动的基本流程是一致的，只不过launch启动比startActvitiy启动多了创建应用程序进程的步骤。下面看一下启动的基本流程。 基本流程 如上图所示 步骤一 用户点击桌面图标 Launch 告诉 AMS ：我要启动MainActivity AMS 保存 MainActivity组件信息：准备好了，Launch你先进入中止状态。 launch 进入中止状态：我进入中止状态了，AMS 你启动 MainActivity 吧。 步骤二 AMS 收到 Launch进入中止状态后开始检查 MainActivity 的应用进程，发现该应用进程不存在通知Zygote：Zygote 你创建MainActivity 的应用进程吧，创建好了告诉我。 Zygote创建完应用进程后告知AMS：创建完成了 AMS收到后继续进入启动MainActivity操作。 详细描述","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"在markdown中插入数学公式","slug":"在markdown中使用数学公式","date":"2017-09-01T16:34:12.000Z","updated":"2019-02-26T07:32:14.744Z","comments":true,"path":"2017/09/02/在markdown中使用数学公式/","link":"","permalink":"https://tanjunze.github.io/2017/09/02/在markdown中使用数学公式/","excerpt":"","text":"在markdown中插入数学公式的\b方法1、使用codecogsAPIcodecogs可以支持多种格式如：gif、png、pdf、swf、emf、svg。(推荐svg格式)12345http://latex.codecogs.com/gif.latex?公式 http://latex.codecogs.com/svg.latex?公式http://latex.codecogs.com/png.latex?公式 \b例如要显示下面的公式： 的公式为 \\frac{1}{1+sin(x)} &gt;在文本中插入如下 1![](http://latex.codecogs.com/svg.latex?\\frac&#123;1&#125;&#123;1+sin(x)&#125;) }) 1&lt;img src=&quot;http://latex.codecogs.com/svg.latex?\\frac&#123;1&#125;&#123;1+sin(x)&#125;&quot;/&gt; =\\frac{1}{1+e^{(-x)}})","categories":[{"name":"markdown","slug":"markdown","permalink":"https://tanjunze.github.io/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://tanjunze.github.io/tags/markdown/"}]},{"title":"上传本地文件到远程linux主机","slug":"上传文件到远程主机","date":"2017-08-17T10:00:04.000Z","updated":"2019-02-22T01:23:14.055Z","comments":true,"path":"2017/08/17/上传文件到远程主机/","link":"","permalink":"https://tanjunze.github.io/2017/08/17/上传文件到远程主机/","excerpt":"","text":"上传本地文件到远程linux主机命令scp /home/work/source.txt work@192.168.0.10:/home/work/ #把本地的source.txt文件拷贝到192.168.0.10机器上的/home/work目录下 scp work@192.168.0.10:/home/work/source.txt /home/work/ #把192.168.0.10机器上的source.txt文件拷贝到本地的/home/work目录下 scp work@192.168.0.10:/home/work/source.txt work@192.168.0.11:/home/work/ #把192.168.0.10机器上的source.txt文件拷贝到192.168.0.11机器的/home/work目录下 scp -r /home/work/sourcedir work@192.168.0.10:/home/work/ #拷贝文件夹，加-r参数 文件下载 wget http://www.linuxsense.org/xxxx/xxx.tar.gz wget -c http://www.linuxsense.org/xxxx/xxx.tar.gz -b：后台下载，Wget默认的是把文件下载到当前目录。 -O：将文件下载到指定的目录中。 -P：保存文件之前先创建指定名称的目录。 -t：尝试连接次数，当Wget无法与服务器建立连接时，尝试连接多少次。 -c：断点续传，如果下载中断，那么连接恢复时会从上次断点开始下载。 -r：使用递归下载","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tanjunze.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tanjunze.github.io/tags/Linux/"}]},{"title":"Android 事件分发","slug":"Android 事件分发","date":"2017-04-09T10:34:05.000Z","updated":"2019-03-13T13:44:57.865Z","comments":true,"path":"2017/04/09/Android 事件分发/","link":"","permalink":"https://tanjunze.github.io/2017/04/09/Android 事件分发/","excerpt":"","text":"Android 事件分发在梳理Android事件分发之前，我们先要理解什么是 事件分发，理解事件分发对我们有哪些作用。首先Android View是树形结构的，View可能会重叠在一起，当我们点击的地方有多个View都可以响应, Android 中事件分发指的是 点击事件 从点击开始分发到 事件被消费响应的一系列过程，当中包括 事件的分发，拦截，消费等过程。掌握好事件分发的过程可以做出酷炫的交互和解决一些复杂的交互冲突过程如 双重滚动嵌套。 View 体系在理解 事件分发之前我们先看一下View的体系。 phoneWindow是Android 中特殊的window，它继承自window类负责具体所有视图的外观和行为。 DecorView是window的具体装饰，是window中最顶层的view。 RootView是一个ViewGorup类型，仅次于 DecorView 的view。 1234567// 源码 phonwWindow.java ,省略部分代码。public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; private final static String TAG = \"PhoneWindow\"; // This is the top-level view of the window, containing the window decor. private DecorView mDecor; 1234567//源码 DecorView.java ,省略部分代码。public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; private static final String TAG = \"DecorView\"; private PhoneWindow mWindow; ViewGroup mContentRoot; 到这里虽然我们了解了phoneWindow,DecorView,RootView，但是事件分发中我们无法操作这三个类，不过 可以帮助我们更好的理解分发的过程。 事件分发ViewGroup，View是我们常用到的控件，这里不在过多的描述，重点关注 事件分发中需要用到的关键方法。 类型 相关方法 Activity ViewGroup View 事件分发 dispatchTouchEvent √ √ √ 事件拦截 onInterceptTouchEvent X √ X 事件消费 onTouchEvent √ √ √ 结合View体系，我们可以了解事件分发的基本流程。 1Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 当事件没有被消费是，向上反馈。 1Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View 到这里，事件分发的基本流程已经完。有时间再补一下完善一点的事件分发的流程吧。 参考： [1]、http://www.gcssloop.com/customview/dispatch-touchevent-source [2]、http://hukai.me/android-deeper-touch-event-dispatch-process/ [3]、 Android 源码 [4]、https://www.programering.com/a/MzMyYzMwATA.html [5]、https://juejin.im/entry/5a33399f6fb9a04517053e75","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"React Native 整理","slug":"react native整理","date":"2017-03-22T15:20:17.000Z","updated":"2019-03-13T14:21:48.915Z","comments":true,"path":"2017/03/22/react native整理/","link":"","permalink":"https://tanjunze.github.io/2017/03/22/react native整理/","excerpt":"","text":"文档react-native 官网 https://facebook.github.io/react-native/ react-native 中文 https://reactnative.cn/ react-native-community https://github.com/react-native-community ReactNative指南 https://github.com/reactnativecn/react-native-guide 工具Expo https://expo.io/ react-native-code-push https://github.com/Microsoft/react-native-code-push UI 框架/组件轮播组件 https://github.com/leecade/react-native-swiper 跨平台UI 组件NativeBase https://github.com/GeekyAnts/NativeBase 跨平台UI 组件ReactNativeElements https://github.com/react-native-training/react-native-elements https://react-native-training.github.io/react-native-elements/ 跨平台UI 组件Shoutem https://shoutem.github.io/docs/ui-toolkit/introduction 跨平台UI 组件kitten https://github.com/akveo/react-native-ui-kitten https://akveo.github.io/react-native-ui-kitten/#/home 跨平台UI 组件MaterialUI https://github.com/xotahal/react-native-material-ui 图标库VectorIcons https://github.com/oblador/react-native-vector-icons 图表ChartsWrapper https://github.com/wuxudong/react-native-charts-wrapper 动画Lottie https://github.com/react-native-community/lottie-react-native Spinkit https://github.com/maxs15/react-native-spinkit SampleF8App https://github.com/fbsamples/f8app http://makeitopen.com/ Reading https://github.com/attentiveness/reading","categories":[{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/tags/前端/"},{"name":"RN","slug":"RN","permalink":"https://tanjunze.github.io/tags/RN/"}]},{"title":"Android broadcast","slug":"Android 广播","date":"2016-10-09T23:35:14.000Z","updated":"2019-02-26T07:29:03.456Z","comments":true,"path":"2016/10/10/Android 广播/","link":"","permalink":"https://tanjunze.github.io/2016/10/10/Android 广播/","excerpt":"","text":"Android BroadcastBroadcast是一个全局的监听器，主要用于监听/ 接收应用发出的广播消息。广播采用订阅-发布设计模式（观察者设计模式），故广播有2个组成重要部分：sendBroadcast和broadcastReceiver。 注册广播1、静态注册注册： 123456&lt;receiver android:name=\".MyBroadcastReceiver\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\"/&gt; &lt;action android:name=\"android.intent.action.INPUT_METHOD_CHANGED\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 使用： 123456789101112public class MyBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = \"MyBroadcastReceiver\"; @Override public void onReceive(Context context, Intent intent) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"Action: \" + intent.getAction() + \"\\n\"); sb.append(\"URI: \" + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + \"\\n\"); String log = sb.toString(); Log.d(TAG, log); Toast.makeText(context, log, Toast.LENGTH_LONG).show(); &#125; &#125; 系统在安装应用程序时注册接收器。如果应用程序当前未运行，系统可以启动应用程序并发送广播。 2、动态注册1BroadcastReceiver br = new MyBroadcastReceiver(); 123IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);this.registerReceiver(br, filter); 1unregisterReceiver(br) 发送广播1、普通广播sendBroadcast：已未定义的顺序向所有接收器发送广播 1234Intent intent = new Intent();intent.setAction(&quot;com.example.broadcast.MY_NOTIFICATION&quot;);intent.putExtra(&quot;data&quot;,&quot;Notice me senpai!&quot;);sendBroadcast(intent); 2、有序广播sendOrderedBroadcast(Intent, String)一次向一个接收器发送广播。当每个接收器依次执行时，它可以将结果传播到下一个接收器，或者它可以完全中止广播，以便它不会传递给其他接收器。通过intent-filter的android:priority属性来设置广播的优先级; 具有相同优先级的接收器将以任意顺序运行。 应用示例：短信广播 3、本地广播即在本应用（同一进程）内发送广播。注意，本地广播只能通过动态注册。 1LocalBroadcastManager.sendBroadcast(Intent) 4、系统广播系统广播 是有 系统 发送的一种形式的广播，开发者无法使用只能接受系统广播。 5、粘粘广播Sticky Broadcast 高版本API上以废弃，不建议使用。 1sendStickyBroadcast(intent); 广播的权限管理在默认的情况下Android 的广播是可以IPC通信（含应用间通信），这种情况下其他app（非目标app）可以接受到你的广播信息从而产生安全隐患也会造成一定的性能开销。 1、应用内的广播通信应用内的广播 不想 被其他app 知晓时。可以考虑使用LocalBroadcast, 2、指定应用间的广播通信、 不接收其他app 的广播 静态注册的情况下，设置：`android:exported=”false” 、 发送给指定的app 的广播 在发送广播时在Intent 中指定报名Intent.setPackage(packageName) 、接收指定app 的广播 在接收指定广播时时可以设置接收广播的权限，如： 1、自定义权限：https://developer.android.com/guide/topics/manifest/permission-element.html 12345&lt;permission android:name=\"com.hello.permission.broadcast\" android:label=\"@string/app_name\" android:permissionGroup=\"@string/hello_world\" android:protectionLevel=\"normal\" &gt; 2、接收端使用自定义权限： 1&lt;uses-permission android:name=\"com.hello.permission.broadcast\"/&gt; 3、发送带权限的广播 12sendBroadcast(new Intent(\"com.example.NOTIFY\"), \"com.hello.permission.broadcast\"); 4、接收带权限的广播 123456&lt;receiver android:name=\".MyBroadcastReceiver\" android:permission=\"com.hello.permission.broadcast\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.AIRPLANE_MODE\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 或 12IntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);registerReceiver(receiver, filter, \"com.hello.permission.broadcast\", null ); 此时广播接收器只能接收相同权限的广播 。 广播扩展知识1、比较静态注册和动态注册 静态注册 动态注册 注册方式 AndroidManifest.xml 代码中注册 生命周期 不受任何组件的生命周期影响，即使app关闭也可以唤醒接收 跟随组件的生命周期变化而变化，需要动态注销 应用场景 需要实时监听广播，如系统广播 需要动态监听广播，如监听文件下载的变化等 2、广播的注意事项广播接收者中不能进行耗时操作，否者会出现AN异常。如果需要执行耗时操作需要在线程中执行。例如： 1234567891011121314151617181920212223242526272829303132333435363738public class MyBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = \"MyBroadcastReceiver\"; @Override public void onReceive(Context context, Intent intent) &#123; final PendingResult pendingResult = goAsync(); Task asyncTask = new Task(pendingResult, intent); asyncTask.execute(); &#125; private static class Task extends AsyncTask &#123; private final PendingResult pendingResult; private final Intent intent; private Task(PendingResult pendingResult, Intent intent) &#123; this.pendingResult = pendingResult; this.intent = intent; &#125; @Override protected String doInBackground(String... strings) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"Action: \" + intent.getAction() + \"\\n\"); sb.append(\"URI: \" + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + \"\\n\"); String log = sb.toString(); Log.d(TAG, log); return log; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); // Must call finish() so the BroadcastReceiver can be recycled. pendingResult.finish(); &#125; &#125;&#125; 3、广播的通信原理广播中通信与Servce中的通信原理都是使用IBinder机制实现的。这里不在过度展开，会另起篇章来深度讨论IBinder机制 参考： [1]、Android Broadcasts [2]、Android Permission","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Android Activity","slug":"Android Activity","date":"2016-09-02T23:55:34.000Z","updated":"2019-03-01T01:29:43.780Z","comments":true,"path":"2016/09/03/Android Activity/","link":"","permalink":"https://tanjunze.github.io/2016/09/03/Android Activity/","excerpt":"","text":"Android Activity一、Activity 的生命周期1、生命周期 （1）如果打开新的Activity并且新的Activity使用透明主题，那么当前Activity不会调用onStop。 （2）打开新的Activity时，当前Activity及新Activity生命周期顺序如下: 12345MainActivity----onPauseSecondActivity----onCreateSecondActivity----onStartSecondActivity----onResumeMainActivity----onStop 2、异常生命周期原因： （1）资源相关的系统配置发生改变导致的Activity被杀死并重新创建。 如：旋转屏幕，键盘改变等..… （2) 资源内存不足导致低优先级的Activity被杀死。 Activty优先级顺序 1、前台Activty,正在和用户交互的Activity，优先级最高。 2、可见但非前台Activity，如在Activity中弹出对话框。 3、后台Activity，如执行了onStop()，优先级最低。 解决 （1）在onSaveInstanceState(),onRestoreInstanceState()保存恢复数据 （2）在android 工程目录下AndroidManifest中配置如下: 1android:configChanges=&quot;screenSize|orientation&quot; configChanges：如下 项目 含义 mcc IMSI(国际移动用户识别码)发生改变，检测到SIM卡，或者更新MCC mnc IMSI网络发生改变,检测到SIM卡，或者更新MCC locale 语言发生改变，用户选择了一个新的语言，文字应该重新显示 touchscreen 触摸屏发生改变，这通常是不应该发生的 keyboard 键盘类型发生改变，例如，用户使用了外部键盘 keyboardHidden 键盘发生改变，例如，用户使用了硬件键盘 navigation 导航发生改变 screenLayout 屏幕的布局发生改变，这可能导致激活不同的显示 fontScale 全局字体大小缩放发生改变 orientation 设备旋转，横向显示和竖向显示模式切换 screenSize 屏幕大小改变了 smallestScreenSize 屏幕的物理大小改变了，如：连接到一个外部的屏幕上 二、启动模式1，standard 标准模式 每启动一个Activity都会重新创建一个新的Activity实例。当一个Activity启动这种模式下新的Activity，新的Activity就会进入启动它Activity的任务栈中。 2，singleTop 栈定复用模式这种模式下，如果新的Activity的实例已经位于任务栈的栈顶，那么新的Activity就不会重新创建，此时它的onNewIntent()被调用。如果新的Activity的实例不位于栈顶，那么就会重新创建。 3，singleTask 栈内复用模式这是一种单一任务栈，系统会创建一个新的任务，并将启动的Activity放入这个新任务的栈底位置。但是，如果现有任务当中已经存在一个该Activity的实例了，那么系统就不会再创建一次它的实例，而是复用这个已经存在的activity，调用 onNewIntent() 方法，并且清空这个activity任务栈上面所有的activity 4，singleInstance 单实例模式单实例模式。这种模式下的Activity只单独的位于独立的任务栈中。整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity共享 公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在 Activity的Flage 1.FLAGE_ACTIVITY_NEW_TASK 新启动Activity就会被放置到一个新的任务当中(与“singleTask”有点类似） 2.FLAGE_ACTIVITY_SINGLE_TOP 作用于singleTop启动模式效果一样 3.FLAGE_ACTIVITY_CLEAR_TOP 如果要启动的Activity在当前任务中已经存在了，就不会再次创建这个Activity的实例，而是会把这个Activity之上的所有Activity全部关闭掉 三、任务栈处理任务栈处理affinity affinity可以用于指定一个Activity更加愿意依附于哪一个任务，在默认情况下，同一个应用程序中的所有Activity都具有相同的affinity，所以，这些Activity都更加倾向于运行在相同的任务当中。当然了，你也可以去改变每个Activity的affinity值，通过元素的taskAffinity属性就可以实现了 alwaysRetainTaskState如果将最底层的那个Activity的这个属性设置为true，那么上面所描述的默认行为就将不会发生，任务中所有的Activity即使过了很长一段时间之后仍然会被继续保留。 clearTaskOnLaunch如果将最底层的那个Activity的这个属性设置为true，那么只要用户离开了当前任务，再次返回的时候就会将最底层Activity之上的所有其它Activity全部清除掉。简单来讲，就是一种和alwaysRetainTaskState完全相反的工作模式，它保证每次返回任务的时候都会是一种初始化状态，即使用户仅仅离开了很短的一段时间。 finishOnTaskLaunch这个属性和clearTaskOnLaunch是比较类似的，不过它不是作用于整个任务上的，而是作用于单个Activity上。如果某个Activity将这个属性设置成true，那么用户一旦离开了当前任务，再次返回时这个Activity就会被清除掉。 四、Activity启动方式1、显示启动 显示启动需要明确的指定被启动对象的组件信息，包括包名和类名 2、隐式启动 隐式启动的Intent能够匹配目标组件的一组IntentFilter中的信息（即匹配一组IntentFilter的 Action,Category,Data）。 在AndroidManifest.xml中一个activity 可以有多个IntentFilter 在IntentFilter中也可以有多组Action,Category,Data IntentFilter中匹配规则 IntentFilter有“Action,Category,Data”的三种匹配方式 1234567public void playMedia(Uri file) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(file); if (intent.resolveActivity(getPackageManager()) != null) &#123; startActivity(intent); &#125;&#125; 12345678&lt;activity ...&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;data android:type=&quot;audio/*&quot; /&gt; &lt;data android:type=&quot;application/ogg&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 五、扩展架构组件数据库 RoomLiveDataViewModel参考： [1]、Activity Lifecycle [2]、Android Tasks and Back Stack [3]、Android Activities [4]、Android Intents [4]、Android intents-filter","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Marketdown 语法","slug":"Markdown语法","date":"2016-08-12T19:01:34.000Z","updated":"2019-02-26T06:29:23.337Z","comments":true,"path":"2016/08/13/Markdown语法/","link":"","permalink":"https://tanjunze.github.io/2016/08/13/Markdown语法/","excerpt":"","text":"Markdown概况Markdown 是由 Daring Fireball 创建的轻量级标记语言 段落和换行符段落由多个空行分隔 标题标题在行的开头使用 1-6 个 # 对应标题1-6个级别，例如： 12345# 一级标题 H1## 二级标题 H2###### 六级标题 H6 另一种使用方式, 在一行中使用多个连续的 #表示 一级标题 ，使用连续的-表示 二级标题。例如： 12一级标题=============== 12二级标题--------------- 分割线使用 *** 或 --- 表示分割线，例如： 1---- 显示如下： 引用 使用 &gt; 表示引用。 123&gt; 引用1&gt; 引用2 列表使用 * 表示无序列表，或者使用 + 或 - 替代。 使用数字如1. 表示有序列表。例如： 123456789## 无序列表* Red* Green* Blue## 有序列表1. Red2. Green3. Blue 任务列表任务列表使用- [ ] 或- [x] 表示任务的未完成 或 完成 状态。 例如： 12- [ ] 未完成 任务选项- [x] 完成 任务选项 代码块使用 一对 ` 表示单行代码，使用一对 多行代码。 例如：123456~~~ gfm单行代码示例：my function name is ` test() `多行代码示例： function test() { console.log(“notice the blank line before this function?”);}123456代码高亮（代码类型）:```rubyrequire &apos;redcarpet&apos;markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html ~~~ 如果需要在代码中使用单引号，需要使用来规避，例如： 1``这个 `代码` 是错误的`` 显示如下： 这个 `代码` 是错误的 表格示例: 123| 标题1 | 标题1 || ----- | ----- || 内容1 | 内容2 | 在标题和内容间的—— 添加 : 表示对齐方式，如:----- 左对齐、:-----:居中对齐，-----:右对齐，例如： 12345| 左对齐 | 居中对齐 | 右对齐 || :----- |:-----:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 链接使用[]()组成。例如： 1[示例网址](http://example.com/) 显示如下： 示例网址 图片使用![]()组成。例如： 1234# 图片相对路径![本地图片](/path/img.png)# 图片http 路径![网络图片](https://d33wubrfki0l68.cloudfront.net/e7ed9fe4bafe46e275c807d63591f85f9ab246ba/e2d28/assets/images/tux.png) 斜体使用 单个* 或单个 (_) 表示斜体，例如： 1*斜体1* 显示如下： 斜体1 粗体使用一对**表示粗体，例如： 1**粗体** 粗体 删除线使用一对~~ 表示删除线（非标准语法，GFM中使用） 1~~不要了~~ 显示如下： 不要了 下划线可以使用html标签&lt;u&gt; &lt;/u&gt;表示，例如： 1&lt;u&gt; 下划线 &lt;/u&gt; 显示如下： 下划线 下标使用 ~表示下标， 例如: 1H~2~O X~long\\ text~ 显示如下： H~2~O X~long\\ text~ 上标使用 ^ 表示上标, 例如: 1X^2^ 显示如下： X^2^ 高亮使用 == 表示高亮， 例如: 1==高亮文字== 显示如下： ==高亮文字== Html 片段例如 ：1&lt;span style=&quot;color:red&quot;&gt;红色文字&lt;/span&gt; 显示如下： 红色文字 反义使用\\ 反义 markdown中的关键字，例如： 1\\* 如果没有反斜杠,这将是无序列表 显示如下： * 如果没有反斜杠,这将是无序列表 可以使用反义的关键字 字符 名称 \\ 反斜线 ` 刻度线 * 星号 _ 下划线 {} 大括号 [] 括号 () 括弧 # 英镑符号 + 加号 - 减号（连字符） . 点 ! 感叹号 参考网址： [1]、markdownguide","categories":[{"name":"Marketdown","slug":"Marketdown","permalink":"https://tanjunze.github.io/categories/Marketdown/"}],"tags":[{"name":"Marketdown","slug":"Marketdown","permalink":"https://tanjunze.github.io/tags/Marketdown/"}]}]}