{"meta":{"title":"Tanjunze笔记","subtitle":null,"description":"tanjunze","author":"tanjunze","url":"https://tanjunze.github.io"},"pages":[{"title":"关于","date":"2018-10-26T13:59:02.000Z","updated":"2018-10-26T06:46:42.415Z","comments":true,"path":"about/index.html","permalink":"https://tanjunze.github.io/about/index.html","excerpt":"","text":"“不积跬步无以至千里，不积小流无以成江海” 关于我Android技术宅，计算机专业 专科生，喜欢折腾。技术栈: H5、Java/Android/Kotlin、Cordova、ReactNative、Weex、Flutter(最爱的框架)，Linux、SQl、TensorFlow、C++ 联系方式邮箱：tan_junze@qq.com Github：https://github.com/tanjunze"}],"posts":[{"title":"","slug":"Untitled","date":"2019-02-20T12:24:00.464Z","updated":"2019-02-20T12:24:37.549Z","comments":true,"path":"2019/02/20/Untitled/","link":"","permalink":"https://tanjunze.github.io/2019/02/20/Untitled/","excerpt":"","text":"服务Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 服务基本上分为两种形式： 启动 当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。 绑定 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 虽然本文档是分开概括讨论这两种服务，但是您的服务可以同时以这两种方式运行，也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是在于您是否实现了一组回调方法：onStartCommand()（允许组件启动服务）和 onBind()（允许绑定服务）。 无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，您可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。 使用清单文件声明服务部分将对此做更详尽的阐述。 注意：服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。 基础知识您应使用服务还是线程？简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件。 因此，您应仅在必要时才创建服务。 如需在主线程外部执行工作，不过只是在用户正在与应用交互时才有此需要，则应创建新线程而非服务。 例如，如果您只是想在 Activity 运行的同时播放一些音乐，则可在 onCreate() 中创建线程，在 onStart() 中启动线程，然后在 onStop() 中停止线程。您还可以考虑使用 AsyncTask或 HandlerThread，而非传统的 Thread 类。如需了解有关线程的详细信息，请参阅进程和线程文档。 请记住，如果您确实要使用服务，则默认情况下，它仍会在应用的主线程中运行，因此，如果服务执行的是密集型或阻止性操作，则您仍应在服务内创建新线程。 要创建服务，您必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，您需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括： onStartCommand() 当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果您实现此方法，则在服务工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。） onBind() 当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。 onCreate() 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法。 onDestroy() 当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。 如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。 如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。 仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的 Activity，则它不太可能会终止；如果将服务声明为在前台运行（稍后讨论），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务（不过这还取决于从 onStartCommand() 返回的值，本文稍后会对此加以讨论）。如需了解有关系统会在何时销毁服务的详细信息，请参阅进程和线程文档。 在下文中，您将了解如何创建各类服务以及如何从其他应用组件使用服务。 使用清单文件声明服务如同 Activity（以及其他组件）一样，您必须在应用的清单文件中声明所有服务。 要声明服务，请添加 元素作为 元素的子元素。例如： 1234567&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;service android:name=&quot;.ExampleService&quot; /&gt; ... &lt;/application&gt;&lt;/manifest&gt; 如需了解有关使用清单文件声明服务的详细信息，请参阅 元素参考文档。 您还可将其他属性包括在 元素中，以定义一些特性，如启动服务及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定服务的类名。应用一旦发布，即不应更改此类名，如若不然，可能会存在因依赖显式 Intent 启动或绑定服务而破坏代码的风险（请阅读博客文章Things That Cannot Change[不能更改的内容]）。 为了确保应用的安全性，请始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。 此外，还可以通过添加 android:exported 属性并将其设置为 &quot;false&quot;，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。 创建启动服务启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。 服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。 应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。 例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。 注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果服务在用户与来自同一应用的 Activity 进行交互时执行密集型或阻止性操作，则会降低 Activity 性能。 为了避免影响应用性能，您应在服务内启动新线程。 从传统上讲，您可以扩展两个类来创建启动服务： Service 这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。 IntentService 这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果您不要求服务同时处理多个请求，这是最好的选择。 您只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，使您能够执行后台工作。 下文介绍如何使用其中任一个类来实现服务。 扩展 IntentService 类由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用IntentService 类实现服务也许是最好的选择。 IntentService 执行以下操作： 创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。 创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。 在处理完所有启动请求后停止服务，因此您永远不必调用 stopSelf()。 提供 onBind() 的默认实现（返回 null）。 提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。 综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。（不过，您还需要为服务提供小型构造函数。） 以下是 IntentService 的实现示例： 123456789101112131415161718192021222324252627public class HelloIntentService extends IntentService &#123; /** * A constructor is required, and must call the super IntentService(String) * constructor with a name for the worker thread. */ public HelloIntentService() &#123; super(&quot;HelloIntentService&quot;); &#125; /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; &#125;&#125; 您只需要一个构造函数和一个 onHandleIntent() 实现即可。 如果您决定还重写其他回调方法（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现，以便 IntentService 能够妥善处理工作线程的生命周期。 例如，onStartCommand() 必须返回默认实现（即，如何将 Intent 传递给 onHandleIntent()）： 12345@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show(); return super.onStartCommand(intent,flags,startId);&#125; 除 onHandleIntent() 之外，您无需从中调用超类的唯一方法就是 onBind()（仅当服务允许绑定时，才需要实现该方法）。 在下一部分中，您将了解如何在扩展 Service 基类时实现同类服务。该基类包含更多代码，但如需同时处理多个启动请求，则更适合使用该基类。 扩展服务类正如上一部分中所述，使用 IntentService 显著简化了启动服务的实现。但是，若要求服务执行多线程（而不是通过工作队列处理启动请求），则可扩展 Service 类来处理每个 Intent。 为了便于比较，以下提供了 Service 类实现的代码示例，该类执行的工作与上述使用 IntentService的示例完全相同。也就是说，对于每个启动请求，它均使用工作线程执行作业，且每次仅处理一个请求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class HelloService extends Service &#123; private Looper mServiceLooper; private ServiceHandler mServiceHandler; // Handler that receives messages from the thread private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; // Stop the service using the startId, so that we don&apos;t stop // the service in the middle of handling another job stopSelf(msg.arg1); &#125; &#125; @Override public void onCreate() &#123; // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process&apos;s // main thread, which we don&apos;t want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread thread = new HandlerThread(&quot;ServiceStartArguments&quot;, Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // Get the HandlerThread&apos;s Looper and use it for our Handler mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show(); // For each start request, send a message to start a job and deliver the // start ID so we know which request we&apos;re stopping when we finish the job Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; mServiceHandler.sendMessage(msg); // If we get killed, after returning from here, restart return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; // We don&apos;t provide binding, so return null return null; &#125; @Override public void onDestroy() &#123; Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 正如您所见，与使用 IntentService 相比，这需要执行更多工作。 但是，因为是由您自己处理对 onStartCommand() 的每个调用，因此可以同时执行多个请求。此示例并未这样做，但如果您希望如此，则可为每个请求创建一个新线程，然后立即运行这些线程（而不是等待上一个请求完成）。 请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从 onStartCommand() 返回的值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 有关这些返回值的更多详细信息，请查阅每个常量链接的参考文档。 启动服务您可以通过将 Intent（指定要启动的服务）传递给 startService()，从 Activity 或其他应用组件启动服务。Android 系统调用服务的 onStartCommand() 方法，并向其传递 Intent。（切勿直接调用 onStartCommand()。） 例如，Activity 可以结合使用显式 Intent 与 startService()，启动上文中的示例服务 (HelloService)： 12Intent intent = new Intent(this, HelloService.class);startService(intent); startService() 方法将立即返回，且 Android 系统调用服务的 onStartCommand() 方法。如果服务尚未运行，则系统会先调用 onCreate()，然后再调用 onStartCommand()。 如果服务亦未提供绑定，则使用 startService() 传递的 Intent 是应用组件与服务之间唯一的通信模式。但是，如果您希望服务返回结果，则启动服务的客户端可以为广播创建一个 PendingIntent （使用 getBroadcast()），并通过启动服务的 Intent 传递给服务。然后，服务就可以使用广播传递结果。 多个服务启动请求会导致多次对服务的 onStartCommand() 进行相应的调用。但是，要停止服务，只需一个服务停止请求（使用 stopSelf() 或 stopService()）即可。 停止服务启动服务必须管理自己的生命周期。也就是说，除非系统必须回收内存资源，否则系统不会停止或销毁服务，而且服务在 onStartCommand() 返回后会继续运行。因此，服务必须通过调用 stopSelf() 自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。 一旦请求使用 stopSelf() 或 stopService() 停止服务，系统就会尽快销毁服务。 但是，如果服务同时处理多个 onStartCommand() 请求，则您不应在处理完一个启动请求之后停止服务，因为您可能已经收到了新的启动请求（在第一个请求结束时停止服务会终止第二个请求）。为了避免这一问题，您可以使用 stopSelf(int) 确保服务停止请求始终基于最近的启动请求。也就说，在调用stopSelf(int) 时，传递与停止请求的 ID 对应的启动请求的 ID（传递给 onStartCommand() 的 startId）。然后，如果在您能够调用 stopSelf(int) 之前服务收到了新的启动请求，ID 就不匹配，服务也就不会停止。 注意：为了避免浪费系统资源和消耗电池电量，应用必须在工作完成之后停止其服务。 如有必要，其他组件可以通过调用 stopService() 来停止服务。即使为服务启用了绑定，一旦服务收到对onStartCommand() 的调用，您始终仍须亲自停止服务。 如需了解有关服务生命周期的详细信息，请参阅下面有关管理服务生命周期的部分。 创建绑定服务绑定服务允许应用组件通过调用 bindService() 与其绑定，以便创建长期连接（通常不允许组件通过调用 startService() 来启动它）。 如需与 Activity 和其他应用组件中的服务进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定服务。 要创建绑定服务，必须实现 onBind() 回调方法以返回 IBinder，用于定义与服务通信的接口。然后，其他应用组件可以调用 bindService() 来检索该接口，并开始对服务调用方法。服务只用于与其绑定的应用组件，因此如果没有组件绑定到服务，则系统会销毁服务（您不必按通过 onStartCommand() 启动的服务那样来停止绑定服务）。 要创建绑定服务，首先必须定义指定客户端如何与服务通信的接口。 服务与客户端之间的这个接口必须是 IBinder 的实现，并且服务必须从 onBind() 回调方法返回它。一旦客户端收到 IBinder，即可开始通过该接口与服务进行交互。 多个客户端可以同时绑定到服务。客户端完成与服务的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该服务，系统就会销毁它。 有多种方法实现绑定服务，其实现比启动服务更为复杂，因此绑定服务将在有关绑定服务的单独文档中专门讨论。 向用户发送通知一旦运行起来，服务即可使用 Toast 通知或状态栏通知来通知用户所发生的事件。 Toast 通知是指出现在当前窗口的表面、片刻随即消失不见的消息，而状态栏通知则在状态栏中随消息一起提供图标，用户可以选择该图标来采取操作（例如启动 Activity）。 通常，当某些后台工作已经完成（例如文件下载完成）且用户现在可以对其进行操作时，状态栏通知是最佳方法。 当用户从展开视图中选定通知时，通知即可启动 Activity（例如查看已下载的文件）。 如需了解详细信息，请参阅 Toast 通知或状态栏通知开发者指南。 在前台运行服务前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。 例如，应该将通过服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。 要请求让服务运行于前台，请调用 startForeground()。此方法采用两个参数：唯一标识通知的整型数和状态栏的 Notification。例如： 1234567Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 注意：提供给 startForeground() 的整型 ID 不得为 0。 要从前台移除服务，请调用 stopForeground()。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果您在服务正在前台运行时将其停止，则通知也会被移除。 如需了解有关通知的详细信息，请参阅创建状态栏通知。 管理服务生命周期服务的生命周期比 Activity 的生命周期要简单得多。但是，密切关注如何创建和销毁服务反而更加重要，因为服务可以在用户没有意识到的情况下运行于后台。 服务生命周期（从创建到销毁）可以遵循两条不同的路径： 启动服务 该服务在其他组件调用 startService() 时创建，然后无限期运行，且必须通过调用stopSelf() 来自行停止运行。此外，其他组件也可以通过调用 stopService() 来停止服务。服务停止后，系统会将其销毁。 绑定服务 该服务在另一个组件（客户端）调用 bindService() 时创建。然后，客户端通过 IBinder 接口与服务进行通信。客户端可以通过调用 unbindService() 关闭连接。多个客户端可以绑定到相同服务，而且当所有绑定全部取消后，系统即会销毁该服务。 （服务不必自行停止运行。） 这两条路径并非完全独立。也就是说，您可以绑定到已经使用 startService() 启动的服务。例如，可以通过使用 Intent（标识要播放的音乐）调用 startService() 来启动后台音乐服务。随后，可能在用户需要稍加控制播放器或获取有关当前播放歌曲的信息时，Activity 可以通过调用 bindService() 绑定到服务。在这种情况下，除非所有客户端均取消绑定，否则 stopService() 或 stopSelf() 不会实际停止服务。 实现生命周期回调与 Activity 类似，服务也拥有生命周期回调方法，您可以实现这些方法来监控服务状态的变化并适时执行工作。 以下框架服务展示了每种生命周期方法： 12345678910111213141516171819202122232425262728293031323334public class ExampleService extends Service &#123; int mStartMode; // indicates how to behave if the service is killed IBinder mBinder; // interface for clients that bind boolean mAllowRebind; // indicates whether onRebind should be used @Override public void onCreate() &#123; // The service is being created &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // The service is starting, due to a call to startService() return mStartMode; &#125; @Override public IBinder onBind(Intent intent) &#123; // A client is binding to the service with bindService() return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; // All clients have unbound with unbindService() return mAllowRebind; &#125; @Override public void onRebind(Intent intent) &#123; // A client is binding to the service with bindService(), // after onUnbind() has already been called &#125; @Override public void onDestroy() &#123; // The service is no longer used and is being destroyed &#125;&#125; 注：与 Activity 生命周期回调方法不同，您不需要调用这些回调方法的超类实现。 图 2. 服务生命周期。左图显示了使用 startService() 所创建的服务的生命周期，右图显示了使用 bindService()所创建的服务的生命周期。 通过实现这些方法，您可以监控服务生命周期的两个嵌套循环： 服务的 整个生命周期 从调用 1onCreate() 开始起，到 1onDestroy() 返回时结束。与 Activity 类似，服务也在 1onCreate() 中完成初始设置，并在 1onDestroy() 中释放所有剩余资源。例如，音乐播放服务可以在 1onCreate() 中创建用于播放音乐的线程，然后在 1onDestroy() 中停止该线程。 无论服务是通过 startService() 还是 bindService() 创建，都会为所有服务调用 onCreate() 和 onDestroy() 方法。 服务的 有效生命周期 从调用 1onStartCommand() 或 1onBind() 方法开始。每种方法均有 1Intent 对象，该对象分别传递到 1startService() 或 1bindService() 。 对于启动服务，有效生命周期与整个生命周期同时结束（即便是在 onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在 onUnbind() 返回时结束。 注：尽管启动服务是通过调用 stopSelf() 或 stopService() 来停止，但是该服务并无相应的回调（没有 onStop() 回调）。因此，除非服务绑定到客户端，否则在服务停止时，系统会将其销毁 — onDestroy()是接收到的唯一回调。 图 2 说明了服务的典型回调方法。尽管该图分开介绍通过 startService() 创建的服务和通过bindService() 创建的服务，但是请记住，不管启动方式如何，任何服务均有可能允许客户端与其绑定。因此，最初使用 onStartCommand()（通过客户端调用 startService()）启动的服务仍可接收对onBind() 的调用（当客户端调用 bindService() 时）。 如需了解有关创建提供绑定的服务的详细信息，请参阅绑定服务文档，该文档的管理绑定服务的生命周期部分提供了有关 onRebind() 回调方法的更多信息。","categories":[],"tags":[]},{"title":"","slug":"Android Broadcasts","date":"2019-02-11T07:28:16.506Z","updated":"2019-02-11T07:29:16.037Z","comments":true,"path":"2019/02/11/Android Broadcasts/","link":"","permalink":"https://tanjunze.github.io/2019/02/11/Android Broadcasts/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Android Service","date":"2019-02-11T06:09:42.070Z","updated":"2019-02-11T07:29:31.504Z","comments":true,"path":"2019/02/11/Android Service/","link":"","permalink":"https://tanjunze.github.io/2019/02/11/Android Service/","excerpt":"","text":"Android Service一、ServiceService 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。 Service有2种启动方式： startService 当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。 bindSevice 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从 onStartCommand() 返回的值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 二、Server的生命周期 注：官网更详细（IntentServie,JobIntentService,binderService,），这里只做抛砖引玉的作用。 参考： [1]、android services","categories":[],"tags":[]},{"title":"在Blog中添加背景图和动效","slug":"在Blog中添加背景图和动效","date":"2018-10-26T14:53:36.000Z","updated":"2018-10-26T07:29:00.498Z","comments":true,"path":"2018/10/26/在Blog中添加背景图和动效/","link":"","permalink":"https://tanjunze.github.io/2018/10/26/在Blog中添加背景图和动效/","excerpt":"记录一次在Blog中添加动态效果。 参考网址：网站动态背景（动态图）和静态背景（背景图片）的主题美化","text":"记录一次在Blog中添加动态效果。 参考网址：网站动态背景（动态图）和静态背景（背景图片）的主题美化 添加蜘蛛网动效需要在html页面的&lt;body&gt;&lt;/body&gt;标签中添加下面的js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;script type=\"text/javascript\"&gt; ! function () &#123; function o(w, v, i) &#123; return w.getAttribute(v) || i &#125; function j(i) &#123; return document.getElementsByTagName(i) &#125; function l() &#123; var i = j(\"script\"), w = i.length, v = i[w - 1]; return &#123; l: w, z: o(v, \"zIndex\", -1), //设置动态图显示的层位，一般-1就行，不用改 o: o(v, \"opacity\", 0.5), //0.5显示的是线条的透明度，可以自行调整 c: o(v, \"color\", \"0,0,0\"), //设置线条的颜色，三个0,0,0分别代表RGB颜色数值，不知道的可以打开PS里的拾色器就可以看到RGB数值了 n: o(v, \"count\", 120), //设置线条显示的数量，有密集恐惧症的朋友可别把数值设置太大哦 &#125; &#125; function k() &#123; r = u.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, n = u.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight &#125; function b() &#123; e.clearRect(0, 0, r, n); var w = [f].concat(t); var x, v, A, B, z, y; t.forEach(function (i) &#123; i.x += i.xa, i.y += i.ya, i.xa *= i.x &gt; r || i.x &lt; 0 ? -1 : 1, i.ya *= i.y &gt; n || i.y &lt; 0 ? -1 : 1, e.fillRect(i.x - 0.5, i.y - 0.5, 1, 1); for (v = 0; v &lt; w.length; v++) &#123; x = w[v]; if (i !== x &amp;&amp; null !== x.x &amp;&amp; null !== x.y) &#123; B = i.x - x.x, z = i.y - x.y, y = B * B + z * z; y &lt; x.max &amp;&amp; (x === f &amp;&amp; y &gt;= x.max / 2 &amp;&amp; (i.x -= 0.03 * B, i.y -= 0.03 * z), A = (x.max - y) / x.max, e.beginPath(), e.lineWidth = A / 2, e.strokeStyle = \"rgba(\" + s.c + \",\" + (A + 0.2) + \")\", e.moveTo(i.x, i.y), e.lineTo(x.x, x.y), e.stroke()) &#125; &#125; w.splice(w.indexOf(i), 1) &#125;), m(b) &#125; var u = document.createElement(\"canvas\"), s = l(), c = \"c_n\" + s.l, e = u.getContext(\"2d\"), r, n, m = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (i) &#123; window.setTimeout(i, 1000 / 45) &#125;, a = Math.random, f = &#123; x: null, y: null, max: 20000 &#125;; u.id = c; u.style.cssText = \"position:fixed;top:0;left:0;z-index:\" + s.z + \";opacity:\" + s.o; j(\"body\")[0].appendChild(u); k(), window.onresize = k; window.onmousemove = function (i) &#123; i = i || window.event, f.x = i.clientX, f.y = i.clientY &#125;, window.onmouseout = function () &#123; f.x = null, f.y = null &#125;; for (var t = [], p = 0; s.n &gt; p; p++) &#123; var h = a() * r, g = a() * n, q = 2 * a() - 1, d = 2 * a() - 1; t.push(&#123; x: h, y: g, xa: q, ya: d, max: 6000 &#125;) &#125; setTimeout(function () &#123; b() &#125;, 100) &#125;();&lt;/script&gt; 添加背景图我的blog的样式有点差异，这记录一下。 在css样式文件中添加一下css:123456body&#123; width:100%; height:auto; background: url(背景图路径) no-repeat fixed; background-size: cover;&#125; 注意：背景图片最好是：1920x1080 背景图片素材网：Toptal 好了，通过以上2步操作就可以实现看的蜘蛛网效果 本blog使用hexo +material-x 搭建，body 标签文件在 &lt;hexo blog path&gt;\\themes\\material-x\\layout\\layout.ejsbody CSS文件在 &lt;hexo blog path&gt;\\themes\\material-x\\source\\less\\_base.less中添加","categories":[],"tags":[]},{"title":"私有Dart Package Sever","slug":"Dart Package Server","date":"2018-10-12T00:00:00.000Z","updated":"2018-12-28T05:43:44.146Z","comments":true,"path":"2018/10/12/Dart Package Server/","link":"","permalink":"https://tanjunze.github.io/2018/10/12/Dart Package Server/","excerpt":"","text":"搭建私有 Dart Package Server1、搭建Dart Package Server","categories":[{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/categories/前端/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://tanjunze.github.io/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"https://tanjunze.github.io/tags/Flutter/"}]},{"title":"Android Activity","slug":"Android Activity","date":"2018-06-17T16:22:04.000Z","updated":"2019-02-21T01:17:09.415Z","comments":true,"path":"2018/06/18/Android Activity/","link":"","permalink":"https://tanjunze.github.io/2018/06/18/Android Activity/","excerpt":"","text":"Android Activity一、Activity 的生命周期 （1）如果打开新的Activity并且新的Activity使用透明主题，那么当前Activity不会调用onStop。 （2）打开新的Activity时，当前Activity及新Activity生命周期顺序如下: 123456789MainActivity----onPauseSecondActivity----onCreateSecondActivity----onStartSecondActivity----onResumeMainActivity----onStop 2.异常生命周期 原因： （1）资源相关的系统配置发生改变导致的Activity被杀死并重新创建。如：旋转屏幕，键盘改变等..… （2) 资源内存不足导致低优先级的Activity被杀死。 Activty优先级顺序 1、前台Activty,正在和用户交互的Activity，优先级最高。 2、可见但非前台Activity，如在Activity中弹出对话框。 3、后台Activity，如执行了onStop()，优先级最低。 ​ 解决 （1）在onSaveInstanceState(),onRestoreInstanceState()保存恢复数据 （2）在android 工程目录下AndroidManifest中配置如下: 1android:configChanges=&quot;screenSize|orientation&quot; configChanges：如下 项目 含义 mcc IMSI(国际移动用户识别码)发生改变，检测到SIM卡，或者更新MCC mnc IMSI网络发生改变,检测到SIM卡，或者更新MCC locale 语言发生改变，用户选择了一个新的语言，文字应该重新显示 touchscreen 触摸屏发生改变，这通常是不应该发生的 keyboard 键盘类型发生改变，例如，用户使用了外部键盘 keyboardHidden 键盘发生改变，例如，用户使用了硬件键盘 navigation 导航发生改变 screenLayout 屏幕的布局发生改变，这可能导致激活不同的显示 fontScale 全局字体大小缩放发生改变 orientation 设备旋转，横向显示和竖向显示模式切换 screenSize 屏幕大小改变了 smallestScreenSize 屏幕的物理大小改变了，如：连接到一个外部的屏幕上 二、Acitvity LaunchMode( 启动模式)四大启动模式 1，standard 标准模式 每启动一个Activity都会重新创建一个新的Activity实例。当一个Activity启动这种模式下新的Activity，新的Activity就会进入启动它Activity的任务栈中。 2，singleTop 栈定复用模式 这种模式下，如果新的Activity的实例已经位于任务栈的栈顶，那么新的Activity就不会重新创建，此时它的onNewIntent()被调用。如果新的Activity的实例不位于栈顶，那么就会重新创建。 3，singleTask 栈内复用模式 这是一种单一任务栈。，系统会创建一个新的任务，并将启动的Activity放入这个新任务的栈底位置。但是，如果现有任务当中已经存在一个该Activity的实例了，那么系统就不会再创建一次它的实例，而是复用这个已经存在的activity，调用 onNewIntent() 方法，并且清空这个activity任务栈上面所有的activity 4，singleInstance 单实例模式 单实例模式。这种模式下的Activity只单独的位于独立的任务栈中。整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity共享 公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在 Activity的Flage 1.1234新启动Activity就会被放置到一个新的任务当中(与“singleTask”有点类似）。2.```FLAGE_ACTIVITY_SINGLE_TOP 作用于singleTop启动模式效果一样 3.FLAGE_ACTIVITY_CLEAR_TOP 如果要启动的Activity在当前任务中已经存在了，就不会再次创建这个Activity的实例，而是会把这个Activity之上的所有Activity全部关闭掉 处理affinity affinity可以用于指定一个Activity更加愿意依附于哪一个任务，在默认情况下，同一个应用程序中的所有Activity都具有相同的affinity，所以，这些Activity都更加倾向于运行在相同的任务当中。当然了，你也可以去改变每个Activity的affinity值，通过元素的taskAffinity属性就可以实现了 清空返回栈 alwaysRetainTaskState如果将最底层的那个Activity的这个属性设置为true，那么上面所描述的默认行为就将不会发生，任务中所有的Activity即使过了很长一段时间之后仍然会被继续保留。 clearTaskOnLaunch如果将最底层的那个Activity的这个属性设置为true，那么只要用户离开了当前任务，再次返回的时候就会将最底层Activity之上的所有其它Activity全部清除掉。简单来讲，就是一种和alwaysRetainTaskState完全相反的工作模式，它保证每次返回任务的时候都会是一种初始化状态，即使用户仅仅离开了很短的一段时间。 finishOnTaskLaunch这个属性和clearTaskOnLaunch是比较类似的，不过它不是作用于整个任务上的，而是作用于单个Activity上。如果某个Activity将这个属性设置成true，那么用户一旦离开了当前任务，再次返回时这个Activity就会被清除掉。 三、Activity启动方式1，显示启动 显示启动需要明确的指定被启动对象的组件信息，包括包名和类名 2，隐式启动 隐式启动的Intent能够匹配目标组件的一组IntentFilter中的信息（即匹配一组IntentFilter的 Action,Category,Data）。 在AndroidManifest.xml中一个activity 可以有多个IntentFilter 在IntentFilter中也可以有多组Action,Category,Data IntentFilter中匹配规则 IntentFilter有“Action,Category,Data”的三种匹配方式 参考： [1]、Activity Lifecycle [2]、Android Tasks and Back Stack [3]、Android Activities","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Docker命令笔记","slug":"Docker命令笔记","date":"2018-06-05T10:15:12.000Z","updated":"2018-10-26T02:20:58.307Z","comments":true,"path":"2018/06/05/Docker命令笔记/","link":"","permalink":"https://tanjunze.github.io/2018/06/05/Docker命令笔记/","excerpt":"一、Docker 安装本示例采用sh脚本安装,其他方式参考Docker CE官网。","text":"一、Docker 安装本示例采用sh脚本安装,其他方式参考Docker CE官网。 0、root用户登陆 1、升级yum包： $ sudo yum update 2、（可选）卸载旧的Docker $ sudo yum erase docker docker-common docker-client docker-compose 4、执行 Docker 安装脚本 $ curl -fsSL https://get.docker.com/ | sh或$ wget -qO- https://get.docker.com/ | sh 5、测试Docker $ docker info 6、设置Docker开机启动 $ sudo systemctl enable docker.service 7、开启Docker服务 $ sudo systemctl start docker 二、Docker Compose 安装 1、下载安装脚本 $ curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s-uname -m` -o /usr/local/bin/docker-compose 2、添加执行权限 $ chmod +x /usr/local/bin/docker-compose 三、Docker 常用命令 Docker 启动 $ sudo systemctl start docker docker 开机启动 $ sudo systemctl enable docker.service docker 当前容器开机启动 $ docker run -d –restart=always 容器终端 $ docker exec -it &lt;容器id&gt; /bin/bash 挂载目录 $ docker run -d -v &lt;主机目录路径&gt;:&lt;容器目录路径 &gt; 示例： $ docker run -d –restart=always -v /root/notebooks:/notebooks -it -p 8888:8888 tensorflow/tensorflow:latest-py3 拉取镜像 $ docker pull &lt;镜像tag&gt; 查看运行中的容器 $ docker ps 查看所有容器 $ docker ps -a 关闭容器 $ docker stop &lt;容器id&gt; 强制删除容器 $ docker rm -f &lt;容器id&gt; 查看镜像文件 $ docker images 删除镜像文件 docker rmi &lt;镜像id&gt; 参考文档 [1]、Docker CE [2]、Docker Compose [3]、Docker 常用命令与操作","categories":[{"name":"Docker","slug":"Docker","permalink":"https://tanjunze.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://tanjunze.github.io/tags/Docker/"}]},{"title":"Frp内网穿透笔记","slug":"Frp内网穿透笔记","date":"2018-05-24T15:54:04.000Z","updated":"2018-10-26T02:21:33.265Z","comments":true,"path":"2018/05/24/Frp内网穿透笔记/","link":"","permalink":"https://tanjunze.github.io/2018/05/24/Frp内网穿透笔记/","excerpt":"https://github.com/fatedier/frp/issues/176","text":"https://github.com/fatedier/frp/issues/176","categories":[{"name":"杂记","slug":"杂记","permalink":"https://tanjunze.github.io/categories/杂记/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://tanjunze.github.io/tags/其他/"}]},{"title":"linux笔记之ssh","slug":"linux笔记之ssh","date":"2018-05-22T15:20:17.000Z","updated":"2018-10-26T05:50:41.011Z","comments":true,"path":"2018/05/22/linux笔记之ssh/","link":"","permalink":"https://tanjunze.github.io/2018/05/22/linux笔记之ssh/","excerpt":"1、ssh自动脚本登陆 1.1、创建shell脚本，如脚本 login.sh内容如下： 1234567#!/usr/bin/expect set timeout 3 spawn ssh user@192.168.3.24 expect \"*password*\" send \"youPassword\\r\" interact","text":"1、ssh自动脚本登陆 1.1、创建shell脚本，如脚本 login.sh内容如下： 1234567#!/usr/bin/expect set timeout 3 spawn ssh user@192.168.3.24 expect \"*password*\" send \"youPassword\\r\" interact 1.2、为自动登陆脚本添加执行权限，如： $ sudo chmod +x ./login.sh 1.3、（可选）为脚本添加别名打开用户目录下的.bash_profile文件 $ vim ~/.bash_profile 添加 别名（如：SSLogin）和 脚本路径（如：/Users/youAccount/home/login.sh）保存并退出， 如： $ alias SSLogin=’/Users/youAccount/home/login.sh’ 刷新环境变量 $ source ~/.bash_profile 在终端中直接使用别名 SSLogin去登陆了,如 $ SSLogin 2、ssh免密码登陆 参考博文：SSH免密码登陆和免ip连接 参考网址： [1]、expect教程中文版 [2]、shell实现SSH自动登陆","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tanjunze.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tanjunze.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://tanjunze.github.io/tags/SSH/"}]},{"title":"使用ngrok实现内网穿透","slug":"使用ngrok实现内网穿透","date":"2018-05-21T16:30:42.000Z","updated":"2018-10-26T05:51:28.378Z","comments":true,"path":"2018/05/22/使用ngrok实现内网穿透/","link":"","permalink":"https://tanjunze.github.io/2018/05/22/使用ngrok实现内网穿透/","excerpt":"","text":"","categories":[{"name":"杂记","slug":"杂记","permalink":"https://tanjunze.github.io/categories/杂记/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://tanjunze.github.io/tags/代理/"}]},{"title":"树莓派笔记之自动挂载nfts移动硬盘","slug":"树莓派笔记之自动挂载nfts移动硬盘","date":"2018-05-21T14:52:53.000Z","updated":"2018-10-26T05:52:43.901Z","comments":true,"path":"2018/05/21/树莓派笔记之自动挂载nfts移动硬盘/","link":"","permalink":"https://tanjunze.github.io/2018/05/21/树莓派笔记之自动挂载nfts移动硬盘/","excerpt":"0、插入ntfs的存储设备如：移动硬盘1、安装ntfs-3g $ sudo apt-get install ntfs-3g 2、查询外接存储目录权限和UUID $ ls -l /dev/disk/by-uuid/ 输出：1lrwxrwxrwx 1 root root 10 Jan 1 1970 0AC4D607C4D5F543 - &gt; ../../sda1 记下UUID - &gt; 0AC4D607C4D5F543的值","text":"0、插入ntfs的存储设备如：移动硬盘1、安装ntfs-3g $ sudo apt-get install ntfs-3g 2、查询外接存储目录权限和UUID $ ls -l /dev/disk/by-uuid/ 输出：1lrwxrwxrwx 1 root root 10 Jan 1 1970 0AC4D607C4D5F543 - &gt; ../../sda1 记下UUID - &gt; 0AC4D607C4D5F543的值 3、创建挂载点并赋权 $ sudo mkdir /mnt/usbdrive $ sudo chmod 770 /mnt/usbdrive 4、使用id命令获取uid，pi用户和组的gid（通常为1000） $ id -u pi $ id -g pi 5、挂载，然后检查/mnt/usbdrive是否可以访问它 $ sudo mount -t ntfs-3g -o uid=1000，gid=1000，umask=007 /dev/sda1/mnt/usbdrive 6、备份驱动目录并插入新的挂载点备份： $ sudo cp /etc/fstab /etc/fstab.backup 打开驱动目录文件并在最后一行写入新的驱动信息 $ sudo nano /etc/fstab 在fstab文件中添加安装信息（用您自己的UUID，uid，gid替换）：1UUID=0AC4D607C4D5F543 /mnt/usbdrive ntfs-3g uid=1000，gid=1000，umask=007 0 0 7、重新启动树莓派 sudo reboot 8、作为NextCloud的存储设备在/mnt/usbdrive驱动（移动硬盘）上配置NextCloud的数据目录，则它应该对www-data用户拥有770权限。您可以简单地将用户www-data添加到pi组中，因为它已经拥有770的权限，如上面在fstab中设置的那样。 $ sudo usermod -a -G pi www-data 参考网址： [1]、How to setup mount / auto-mount USB Hard Drive on Raspberry Pi [2]、NTFS External HD With ownCloud on the Raspberry Pi [3]、NTFS-3g HDD 0770 and 0777 permissions Owncloud [4]、通过 NextCloudPi 为树莓派可视化搭建 NextCloud 网盘（并折腾无语的 NTFS 移动硬盘） [5]、给树莓派挂载移动硬盘或U盘 [6]、树莓派Raspberry Pi 打造低成本NAS存储家庭服务器的十个问题整理","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/categories/树莓派/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/tags/树莓派/"}]},{"title":"树莓派笔记之NextCloud安装","slug":"树莓派笔记之NextCloud安装","date":"2018-05-21T13:32:27.000Z","updated":"2018-10-26T05:52:34.453Z","comments":true,"path":"2018/05/21/树莓派笔记之NextCloud安装/","link":"","permalink":"https://tanjunze.github.io/2018/05/21/树莓派笔记之NextCloud安装/","excerpt":"Nextcloud 是一个免费专业的私有云存储网盘「开源」项目，可以让你简单快速地在个人/公司电脑、服务器甚至是树莓派等设备上架设一套属于自己或团队专属的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。 1、NextCloud简单安装的三种方式总结 1.1、使用 docker 安装：文档：https://github.com/nextcloud/docker 1.2、使用 nextcloud-snap 安装文档：https://github.com/nextcloud/nextcloud-snap 1.3 使用VM安装文档：https://github.com/nextcloud/vm","text":"Nextcloud 是一个免费专业的私有云存储网盘「开源」项目，可以让你简单快速地在个人/公司电脑、服务器甚至是树莓派等设备上架设一套属于自己或团队专属的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。 1、NextCloud简单安装的三种方式总结 1.1、使用 docker 安装：文档：https://github.com/nextcloud/docker 1.2、使用 nextcloud-snap 安装文档：https://github.com/nextcloud/nextcloud-snap 1.3 使用VM安装文档：https://github.com/nextcloud/vm NextCloud安装官方文档：https://nextcloud.com/install/#instructions-server 2、NextCloud在树莓派上的安装方式NextCloudPI官方文档：https://github.com/nextcloud/nextcloudpi 2.1、自己构建环境和部署NextCloud博文：在Raspberry Pi上简单安装Nextcloud 2.1、自动脚本构建NextCloud博文：在Raspberry Pi上自动安装Nextcloud 2.3、刷NextCloudPi镜像文件博文：树莓派Raspberry Pi安装NextCloud教程-自建家庭私有云局域网共享 2.4 使用 docker 安装：文档：NextCloudPI Github 3、NextCloud快速安装笔记 这里记录我目前使用的安装方式 步骤2.1中关键命令，方便查阅： 3.1、下载Ansible $ sudo apt-get -y install ansible 3.2、下载自动构建脚本 $ wget https://raw.githubusercontent.com/webtaster/Nextcloud/master/build_nextcloud.yml 3.3、(可选)使用 SQLite安装和配置Nextcloud $ sudo date ; ansible-playbook -s -c local -i “localhost,” build_nextcloud.yml 3.4、(可选)使用 MySQL安装和配置Nextcloud $ date ; ansible-playbook -s -c local -i “localhost,” –extra-vars “DATABASE=mysql MYSQL_ROOT_PASSWORD=qwerty NCUSER_PASSWORD=raindrop” build_nextcloud.yml 上面指令中MySQL用户密码（可以自定义）：用户：root 密码：qwerty 对应命令：MYSQL_ROOT_PASSWORD = qwerty用户：ncuser 密码：rainindrop 对应命令：NCUSER_PASSWORD = raindrop 3.5、初始化配置NextCloud在浏览器中打开 http://树莓派的IP地址/nextcloud 例如： http://192.168.1.99/nextcloud 然后根据NextCloud提示配置NextCloud就可以了。 3.6、(可选)配置树莓派目录读写权限如果在浏览器中配置NextCloud过程中错误提示“无法创建var/www/html/nextcloud/data“时，ssh等登陆树莓派并赋予775权限 $ sudo chmod -R 775 /var/www/html/nextcloud/","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/categories/树莓派/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/tags/树莓派/"}]},{"title":"树莓派笔记之安装配置","slug":"树莓派笔记之安装配置","date":"2018-05-21T09:38:43.000Z","updated":"2018-10-26T05:52:39.303Z","comments":true,"path":"2018/05/21/树莓派笔记之安装配置/","link":"","permalink":"https://tanjunze.github.io/2018/05/21/树莓派笔记之安装配置/","excerpt":"前言： 这篇笔记记录不使用显示屏和网线来安装系统和配置环境 1、准备 树莓派3b+板子 SD存储卡和卡套 电源线和插头 路由器（有wifi就行）","text":"前言： 这篇笔记记录不使用显示屏和网线来安装系统和配置环境 1、准备 树莓派3b+板子 SD存储卡和卡套 电源线和插头 路由器（有wifi就行） 2、\b刻录\b系统 2.1、到树莓派官网下载系统系统文件并解压 2.2、下载安装镜像刻录软件如：\bMac版Etcher和window版win32diskimager等 2.3、插入SD卡到电脑并打开刻录软件如：\b目前使用的Etcher（示例） 2.3.1、选择（Select image）\b\b从官网下载并解压\b后的 NOOBS \b或 RASPBIAN \b\b镜像文件（ xxx.img \b格式） 2.3.2、选择SD\b卡 (Select drive) 2.3.3 \b开始刻录镜像（Flash）并等待及几分钟至镜像刻录完成\b 3、\b\b配置wif\bi和ssh因为没有使用\b网线所以要在安装前配置好wifi和ssh，\b\b让\b\b板子在安装完系统后自动连接wifi并开启ssh。 3.1、配置wifi 打开SD卡，创建文件并写入保存：文件名：wpa_supplicant.conf 12345678910country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;ssid=&quot;mywifi&quot; #ssid（wifi名）psk=&quot;123456&quot; #password（wifi密码）key_mgmt=WPA-PSK #wifi加密方式priority=1 #优先级&#125; 3.2、配置ssh 打开SD卡，创建文件ssh文件(不写入内容，无后缀)文件名：ssh 4、安装系统并ssh登陆 4.1、将SD卡插入板子中并上电启动，如果绿灯不在闪烁且红灯常亮，那么系统安装并启动成功。 4.2、进入路由器查看名称为 raspberry设备的 IP地址，例如：设备：raspberry ，IP地址：192.168.1.56。如果没有查看到 raspberry设备和IP，请确认 步骤3.1 中文件 wpa_supplicant.conf是否正确配置wifi名称和密码。如果错误请重新刻录系统并配置wifi。 4.3、确认到 raspberry的IP（例如：192.168.1.56）后在电脑中打开终端（window使用xshell）连接到 Raspberry PI 板子的 ssh服务，例如： ssh pi@192.168.1.56 然后输入密码：raspberry(系统默认) 4.4、ssh登陆完成后就可以对板子操作了！ 5、设置wifi在板子断电或重启后自动连接网络 5.1、ssh登陆后执行 sudo nano /etc/network/interfaces 12345678910111213auto loiface lo inet loopbackiface eth0 inet dhcpallow-hotplug wlan0iface wlan0 inet dhcpwpa-ssid &quot;mywifi&quot;wpa-psk &quot;123456&quot; 保存退出 参考博文：Raspberry Pi树莓派无线网卡配置[多重方法备选] 6、安全管理 建议修改默认账户密码如： 用户：pi 密码：raspberry 注： 1、nano 编辑器 操作 退出：control x保存并退出： control o 保存 enter q确认 control x 退出 2、linxu c重启命令 sudo reboot 参考博文： [1]、树莓派如何完全无头(无屏无网线无键盘鼠标)安装 [2]、树莓派 - 修改pi账号密码,开启root账号 [3]、Raspberry Pi树莓派无线网卡配置[多重方法备选] [4]、NextCloud论坛","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/categories/树莓派/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://tanjunze.github.io/tags/树莓派/"}]},{"title":"Android手机搭建Linux环境","slug":"Android手机搭建Linux环境","date":"2018-05-17T16:22:04.000Z","updated":"2018-10-26T05:50:02.477Z","comments":true,"path":"2018/05/18/Android手机搭建Linux环境/","link":"","permalink":"https://tanjunze.github.io/2018/05/18/Android手机搭建Linux环境/","excerpt":"Termux介绍 Termux是Android，Chromebook和Fire OS的终端模拟器和Linux环境。","text":"Termux介绍 Termux是Android，Chromebook和Fire OS的终端模拟器和Linux环境。官网：https://wiki.termux.comgithub：https://github.com/termux/termux-app 1、配置Termux。1.1 升级 apt(否则无法安装软件)1apt update 1.2 安装openssh1apt intall openssh","categories":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://tanjunze.github.io/tags/Android/"}]},{"title":"Mac使用Android代理翻墙记录","slug":"Mac使用Android代理翻墙记录","date":"2018-05-17T15:29:09.000Z","updated":"2018-10-26T05:51:01.374Z","comments":true,"path":"2018/05/17/Mac使用Android代理翻墙记录/","link":"","permalink":"https://tanjunze.github.io/2018/05/17/Mac使用Android代理翻墙记录/","excerpt":"1、下载Proxy Server代理软件2、创建一个代理服务（Proxy Server）","text":"1、下载Proxy Server代理软件2、创建一个代理服务（Proxy Server） 3、设置服务名和端口并返回后点击Start按钮启动服务 4、打开FireFox浏览器并配置网络代理 5、设置启动代理服务手机的Ip和上面填写端口 到此 FireFox 可以使用手机的代理服务，如果手机已经翻墙了，那么FireFox就可以实现翻墙。 同样可以为电脑设置代理配置，实现全局代理。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://tanjunze.github.io/categories/杂记/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://tanjunze.github.io/tags/代理/"}]},{"title":"机器学习资料整理","slug":"机器学习资料整理","date":"2018-04-27T15:36:40.000Z","updated":"2018-10-26T05:52:14.126Z","comments":true,"path":"2018/04/27/机器学习资料整理/","link":"","permalink":"https://tanjunze.github.io/2018/04/27/机器学习资料整理/","excerpt":"我的机器学习资料，为了方便查询同步到笔记中。 机器学习资料文档资料 深度学习资料-Github 神经网络和深度学习•Michael Nielsen 神经网络和深度学习•Michael Nielsen（翻译）","text":"我的机器学习资料，为了方便查询同步到笔记中。 机器学习资料文档资料 深度学习资料-Github 神经网络和深度学习•Michael Nielsen 神经网络和深度学习•Michael Nielsen（翻译） 深度学习•Bengio 深度学习•Bengio（翻译） Tensorflow官网-国内 Tensorflow社区-国内 深度学习资料整理1-国内 深度学习路线图 深度学习博文 深度学习Java框架 在线教育 Google深度学习-Udacity课程 Google机器学习速成课程 深度学习-Stanford-UFLDL 深度学习-Stanford-Tutorial 人工智能实践：Tensorflow笔记-慕课网 莫烦Python 工具 python jupyter notebook 框架 Tensorflow Tensorflow（极客学院-翻译） TensorLayer-中文 TensorLayer scikit-learn scikit-learn 翻译 caffe 或 caffe2 Keras keras 翻译 theano … 其他文档 Deepmind 积卷神经网络-斯坦福 Siraj Raval-Gitub-Youtube CS231n课程-积卷网络 CS231n课程-积卷网络-中文翻译 深度学习-开源项目 音频合成-Merlin 音频合成-Wavenet 深度学习-Udacity-Code 无人驾驶-BehavioralCloning) 无人驾驶-udacity-sim 无人驾驶-CSDN博文 机器学习数据集 机器学习数据集1-知乎提问 机器学习数据集2-知乎博文","categories":[{"name":"资料","slug":"资料","permalink":"https://tanjunze.github.io/categories/资料/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://tanjunze.github.io/tags/机器学习/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://tanjunze.github.io/tags/TensorFlow/"}]},{"title":"Hexo/GitHub Pages搭建个人博客","slug":"Hexo搭建个人博客","date":"2018-04-27T13:53:59.000Z","updated":"2018-10-26T05:50:17.080Z","comments":true,"path":"2018/04/27/Hexo搭建个人博客/","link":"","permalink":"https://tanjunze.github.io/2018/04/27/Hexo搭建个人博客/","excerpt":"前言好久没有在github pages 中更新笔记了，刚把旧的github仓库重新整理了。在此记录一下，日后逐渐将旧笔记往这里迁移。","text":"前言好久没有在github pages 中更新笔记了，刚把旧的github仓库重新整理了。在此记录一下，日后逐渐将旧笔记往这里迁移。 1、配置环境Hexo官方文档: Hexo wiki \b首先安装: Node.js Git 再安装 Hexo1$ npm install -g hexo-cli \b到此Hexo安装完成，如果\b失败\b请参考官网，这里只记录简单流程。 2、搭建站点执行命令：123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 3\b、配置\b站点\b打开 folder/_config.yml 文件修改配置即可 4、\b启动服务1$ hexo server \b\b\b\b简写1$ hexo s 此时控制台中打印出 http://localhost:4000/ ,\b再\b使用\b\b\b\b浏览器打开你就可以\b看到Hello world页面了。 5、\b发布到github上参考：Hexo 部署 \b注意：首先\b你需要创建github账户，gtihub的仓库并push、pull\b\b仓库已验证\b你的github配置完成。 再\b创建一个仓库命名为&lt;\b你的用户名&gt;.github.io,如： tanjunze.github.io 打开本地&lt;folder&gt; Hexo工程安装 hexo-deployer-git123cd &lt;folder&gt;npm install hexo-deployer-git --save \b\b\b打开本地folder/_config.yml找到Deployment选项，并修改：其中将repo改为1git@github.com:&lt;你的账户名&gt;/&lt;你的账户名&gt;.github.io.git 执行1hexo deploy 如果push成功，打开https://&lt;\b你的用户名&gt;.github.io,例如： https://tanjunze.github.io/ 恭喜你成功搭建了在Hexo + Gtihub Pages 的个人免费站点了。 参考网址：http://www.cnblogs.com/zhcncn/p/4097881.html","categories":[{"name":"杂记","slug":"杂记","permalink":"https://tanjunze.github.io/categories/杂记/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://tanjunze.github.io/tags/其他/"}]},{"title":"Dart 之旅","slug":"Dart之旅","date":"2018-03-21T20:10:13.000Z","updated":"2019-01-02T11:35:05.859Z","comments":true,"path":"2018/03/22/Dart之旅/","link":"","permalink":"https://tanjunze.github.io/2018/03/22/Dart之旅/","excerpt":"","text":"dartpad 特性 所有的变量引用都是对象，每个对象都是一个类的实例。在Dart 中甚至 数字（numbers）、方法（functions）和null都是对象。所有对象都继承Object类。 尽管Dart 是强类型语言，但是类型声明是可选的，因为Dart可以推断类型。如果要明确说明不需要任何类型， 则使用特殊类型dynamic。 Dart 支持泛型，例如List 或List。 Dart 支持顶级方法（如main()），静态方法，实例方法和方法内方法（嵌套函数和本地函数）。 Dart 支持顶级变量，以及类中定义变量（静态变量和实例变量）。实例变量有时称为字段和属性。 与Java不同的是，Dart 中没有public,private,protected关键字，如果标识符已（_）开头，则其是私有的。 标识符可以以字母或下划线（_）开头，后跟这些字符加数字的任意组合。 Dart有两个表达式（具有运行时值）和 语句（不具有）。例如，条件表达式 condition ? expr1 : expr2的值为expr1或expr2。将其与if-else语句进行比较，该语句没有任何值。语句通常包含一个或多个表达式，但表达式不能直接包含语句。 Dart工具可以报告两种问题：警告和错误。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误会阻止代码执行; 运行时错误导致 代码执行时引发异常。 变量12var name='Bob';dynamic name = 'Bob' ; 默认值未初始化的变量默认为null。 1int lineCount ; assert （lineCount == null ）; final 和 const如果不打算修改一个变量，使用final或const,final 修饰的变量只能赋值一次；一个const变量是编译时常量。（const变量同时也是final变量。）顶级的final 变量或类中的final变量在第一次使用时初始化。 12345678910final name = 'Bob'; final String nickname = 'Bobby';const bar = 1000000；const double atm = 1.01325 * bar;var foo = const [];final bar = const [];const baz = []; // 等价于`const []`foo = [1, 2, 3]; // const []baz = [42]; // 错误 不能赋值 内置类型number123456789101112131415161718192021222324252627282930// int 类型var x = 1 ;var hex = 0xDEADBEEF ; // double 类型var y = 1.1 ; var exponents = 1.42e5 ; double z = 1 ; //相当于double z = 1.0。 // 类型转换// String -&gt; intvar one = int.parse('1');assert(one == 1);// String -&gt; doublevar onePointOne = double.parse('1.1');assert(onePointOne == 1.1);// int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == '1');// double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == '3.14');assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001assert((3 | 4) == 7); // 0011 | 0100 == 0111const msPerSecond = 1000;const secondsUntilRetry = 5;const msUntilRetry = secondsUntilRetry * msPerSecond; StringDart String 是UTF-16编码，可以使用&#39;或&quot; 1234var s1 = 'Single quotes work well for string literals.';var s2 = \"Double quotes work just as well.\";var s3 = 'It\\'s easy to escape the string delimiter.';var s4 = \"It's even easier to use the other delimiter.\"; 字符串拼接 1234567891011121314151617181920212223242526272829303132333435var s = 'string interpolation';assert('Dart has $s, which is very handy.' == 'Dart has string interpolation, ' + 'which is very handy.'); // trueassert('That deserves all caps. ' + '$&#123;s.toUpperCase()&#125; is very handy!' == 'That deserves all caps. ' + 'STRING INTERPOLATION is very handy!'); // truevar s1 = 'String ' 'concatenation' \" works even over line breaks.\";assert(s1 == 'String concatenation works even over ' 'line breaks.'); // truevar s2 = 'The + operator ' + 'works, as well.';assert(s2 == 'The + operator works, as well.'); // truevar s = r'In a raw string, not even \\n gets special treatment.';// These work in a const string.const aConstNum = 0;const aConstBool = true;const aConstString = 'a constant string';// These do NOT work in a const string.var aNum = 0;var aBool = true;var aString = 'a string';const aConstList = [1, 2, 3];const validConstString = '$aConstNum $aConstBool $aConstString';// const invalidConstString = '$aNum $aBool $aString $aConstList'; Booleans123456789101112131415// Check for an empty string.var fullName = '';assert(fullName.isEmpty);// Check for zero.var hitPoints = 0;assert(hitPoints &lt;= 0);// Check for null.var unicorn;assert(unicorn == null);// Check for NaN.var iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); List12345678910var list = [1, 2, 3];var list = [1, 2, 3];assert(list.length == 3);assert(list[1] == 2);list[1] = 1;assert(list[1] == 1);var constantList = const [1, 2, 3];// constantList[1] = 1; // Uncommenting this causes an error. Maps12345678910111213141516171819202122232425262728293031323334353637383940414243var gifts = &#123; // Key: Value 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings'&#125;;var nobleGases = &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;var gifts = Map();gifts['first'] = 'partridge';gifts['second'] = 'turtledoves';gifts['fifth'] = 'golden rings';var nobleGases = Map();nobleGases[2] = 'helium';nobleGases[10] = 'neon';nobleGases[18] = 'argon';var gifts = &#123;'first': 'partridge'&#125;;gifts['fourth'] = 'calling birds'; // Add a key-value pairvar gifts = &#123;'first': 'partridge'&#125;;assert(gifts['first'] == 'partridge');var gifts = &#123;'first': 'partridge'&#125;;assert(gifts['fifth'] == null);var gifts = &#123;'first': 'partridge'&#125;;gifts['fourth'] = 'calling birds';assert(gifts.length == 2);// truefinal constantMap = const &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;// constantMap[2] = 'Helium'; // Uncommenting this causes an error. Runes表达Unicode代码的常用方法是 \\uXXXX，其中XXXX是4位十六进制值。例如，心脏（♥）是\\u2665。要是多于或少于4个十六进制数字，将值放在大括号中。例如，笑表情符号（😆）是\\u{1f600}。 1234567891011121314main() &#123; var clapping = '\\u&#123;1f44f&#125;'; print(clapping); print(clapping.codeUnits); print(clapping.runes.toList()); // 👏 //[55357, 56399] //[128079] Runes input = new Runes( '\\u2665 \\u&#123;1f605&#125; \\u&#123;1f60e&#125; \\u&#123;1f47b&#125; \\u&#123;1f596&#125; \\u&#123;1f44d&#125;'); print(new String.fromCharCodes(input)); // ♥ 😅 😎 👻 🖖 👍&#125; 方法1234bool isNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125;bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null; 可选参数可选参数可以是命名参数或者基于位置的参数，但是这两种参数不能同时当做可选参数。 Optional named parameters（可选命名参数）调用函数时，可以使用指定命名参数 。例如：*paramName*: *value* 1enableFlags （bold ：true ，hidden ：false ）; 定义函数时，用于 {param1, param2, …}指定命名参数。 1void enableFlags(&#123;bool bold, bool hidden&#125;) &#123;...&#125; Optional positional parameters（可选位置参数）把一些方法的参数放到 [] 中就变成可选 位置参数了： 1234567891011String say(String from, String msg, [String device]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; return result;&#125;assert(say('Bob', 'Howdy') == 'Bob says Howdy'); //trueassert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal');// true Default parameter values（默认参数值）12345678910111213141516171819202122232425262728293031/// Sets the [bold] and [hidden] flags ...void enableFlags(&#123;bool bold = false, bool hidden = false&#125;) &#123;...&#125;// bold will be true; hidden will be false.enableFlags(bold: true);String say(String from, String msg, [String device = 'carrier pigeon', String mood]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; if (mood != null) &#123; result = '$result (in a $mood mood)'; &#125; return result;&#125;assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');void doStuff( &#123;List&lt;int&gt; list = const [1, 2, 3], Map&lt;String, String&gt; gifts = const &#123; 'first': 'paper', 'second': 'cotton', 'third': 'leather' &#125;&#125;) &#123; print('list: $list'); print('gifts: $gifts');&#125;","categories":[{"name":"Dart","slug":"Dart","permalink":"https://tanjunze.github.io/categories/Dart/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://tanjunze.github.io/tags/Dart/"}]},{"title":"Flutter 整理","slug":"Flutter整理2","date":"2017-10-04T18:33:09.000Z","updated":"2018-12-29T02:11:58.408Z","comments":true,"path":"2017/10/05/Flutter整理2/","link":"","permalink":"https://tanjunze.github.io/2017/10/05/Flutter整理2/","excerpt":"","text":"Dart Packagehttps://www.dartlang.org/tools/pub 创建dart 包https://www.dartlang.org/guides/libraries/create-library-packages dart包依赖https://www.dartlang.org/tools/pub/dependencies#path-packages 依赖自建 pub serverhttps://www.dartlang.org/tools/pub/dependencies#hosted-packages 自建私有服务器Github： pub server 依赖Git仓库https://www.dartlang.org/tools/pub/dependencies#git-packages 本地仓库依赖https://www.dartlang.org/tools/pub/dependencies#path-packages Flutter Packagehttps://flutter.io/docs/development/packages-and-plugins/using-packages 开发Flutter包https://flutter.io/docs/development/packages-and-plugins/developing-packages","categories":[{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/categories/前端/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tanjunze.github.io/tags/Flutter/"},{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/tags/前端/"}]},{"title":"Flutter 整理","slug":"Flutter整理","date":"2017-10-04T18:33:09.000Z","updated":"2018-12-29T01:51:26.361Z","comments":true,"path":"2017/10/05/Flutter整理/","link":"","permalink":"https://tanjunze.github.io/2017/10/05/Flutter整理/","excerpt":"","text":"文档Flutter 官网 https://flutter.io/ Flutter 中文 官方：https://flutter-io.cn/ 社区：https://flutterchina.club/ Dart官网 https://www.dartlang.org/ Dart包管理 https://pub.dartlang.org/ https://pub.flutter-io.cn/ Flutter 桌面版 社区：https://github.com/google/flutter-desktop-embedding 其他：https://feather-apps.com/ codelabs中文：https://codelabs.flutter-io.cn/ 工具json_serializable https://caijinglong.github.io/json2dart/index_ch.html 动画 https://www.2dimensions.com/runtimes 博文闲鱼 https://www.yuque.com/xytech/flutter","categories":[{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/categories/前端/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://tanjunze.github.io/tags/Flutter/"},{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/tags/前端/"}]},{"title":"Marketdown 语法","slug":"Markdown语法","date":"2017-08-21T20:20:17.000Z","updated":"2018-12-28T09:42:42.285Z","comments":true,"path":"2017/08/22/Markdown语法/","link":"","permalink":"https://tanjunze.github.io/2017/08/22/Markdown语法/","excerpt":"","text":"Markdown概况Markdown 是由 Daring Fireball 创建的轻量级标记语言 段落和换行符段落由多个空行分隔 标题标题在行的开头使用 1-6 个 # 对应标题1-6个级别，例如： 12345# 一级标题 H1## 二级标题 H2###### 六级标题 H6 另一种使用方式, 在一行中使用多个连续的 #表示 一级标题 ，使用连续的-表示 二级标题。例如： 12一级标题=============== 12二级标题--------------- 分割线使用 *** 或 --- 表示分割线，例如： 1---- 显示如下： 引用 使用 &gt; 表示引用。 123&gt; 引用1&gt; 引用2 列表使用 * 表示无序列表，或者使用 + 或 - 替代。 使用数字如1. 表示有序列表。例如： 123456789## 无序列表* Red* Green* Blue## 有序列表1. Red2. Green3. Blue 任务列表任务列表使用- [ ] 或- [x] 表示任务的未完成 或 完成 状态。 例如： 12- [ ] 未完成 任务选项- [x] 完成 任务选项 代码块使用 一对 ` 表示单行代码，使用一对 多行代码。 例如：123456~~~ gfm单行代码示例：my function name is ` test() `多行代码示例： function test() { console.log(“notice the blank line before this function?”);}123456代码高亮（代码类型）:```rubyrequire &apos;redcarpet&apos;markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html ~~~ 如果需要在代码中使用单引号，需要使用来规避，例如： 1``这个 `代码` 是错误的`` 显示如下： 这个 `代码` 是错误的 表格示例: 123| 标题1 | 标题1 || ----- | ----- || 内容1 | 内容2 | 在标题和内容间的—— 添加 : 表示对齐方式，如:----- 左对齐、:-----:居中对齐，-----:右对齐，例如： 12345| 左对齐 | 居中对齐 | 右对齐 || :----- |:-----:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 链接使用[]()组成。例如： 1[示例网址](http://example.com/) 显示如下： 示例网址 图片使用![]()组成。例如： 1234# 图片相对路径![本地图片](/path/img.png)# 图片http 路径![网络图片](https://d33wubrfki0l68.cloudfront.net/e7ed9fe4bafe46e275c807d63591f85f9ab246ba/e2d28/assets/images/tux.png) 斜体使用 单个* 或单个 (_) 表示斜体，例如： 1*斜体1* 显示如下： 斜体1 粗体使用一对**表示粗体，例如： 1**粗体** 粗体 删除线使用一对~~ 表示删除线（非标准语法，GFM中使用） 1~~不要了~~ 显示如下： 不要了 下划线可以使用html标签&lt;u&gt; &lt;/u&gt;表示，例如： 1&lt;u&gt; 下划线 &lt;/u&gt; 显示如下： 下划线 下标使用 ~表示下标， 例如: 1H~2~O X~long\\ text~ 显示如下： H~2~O X~long\\ text~ 上标使用 ^ 表示上标, 例如: 1X^2^ 显示如下： X^2^ 高亮使用 == 表示高亮， 例如: 1==高亮文字== 显示如下： ==高亮文字== Html 片段例如 ：1&lt;span style=&quot;color:red&quot;&gt;红色文字&lt;/span&gt; 显示如下： 红色文字 反义使用\\ 反义 markdown中的关键字，例如： 1\\* 如果没有反斜杠,这将是无序列表 显示如下： * 如果没有反斜杠,这将是无序列表 可以使用反义的关键字 字符 名称 \\ 反斜线 ` 刻度线 * 星号 _ 下划线 {} 大括号 [] 括号 () 括弧 # 英镑符号 + 加号 - 减号（连字符） . 点 ! 感叹号 参考网址： [1]、markdownguide","categories":[{"name":"Other","slug":"Other","permalink":"https://tanjunze.github.io/categories/Other/"}],"tags":[{"name":"Other","slug":"Other","permalink":"https://tanjunze.github.io/tags/Other/"}]},{"title":"React Native 整理","slug":"react native整理","date":"2017-03-22T15:20:17.000Z","updated":"2018-12-28T07:31:24.551Z","comments":true,"path":"2017/03/22/react native整理/","link":"","permalink":"https://tanjunze.github.io/2017/03/22/react native整理/","excerpt":"","text":"文档react-native 官网 https://facebook.github.io/react-native/ react-native 中文 https://reactnative.cn/ react-native-community https://github.com/react-native-community ReactNative指南 https://github.com/reactnativecn/react-native-guide 工具Expo https://expo.io/ react-native-code-push https://github.com/Microsoft/react-native-code-push UI 框架/组件轮播组件 https://github.com/leecade/react-native-swiper 跨平台UI 组件NativeBase https://github.com/GeekyAnts/NativeBase 跨平台UI 组件ReactNativeElements https://github.com/react-native-training/react-native-elements https://react-native-training.github.io/react-native-elements/ 跨平台UI 组件Shoutem https://shoutem.github.io/docs/ui-toolkit/introduction 跨平台UI 组件kitten https://github.com/akveo/react-native-ui-kitten https://akveo.github.io/react-native-ui-kitten/#/home 跨平台UI 组件MaterialUI https://github.com/xotahal/react-native-material-ui 图标库VectorIcons https://github.com/oblador/react-native-vector-icons 图表ChartsWrapper https://github.com/wuxudong/react-native-charts-wrapper 动画Lottie https://github.com/react-native-community/lottie-react-native Spinkit https://github.com/maxs15/react-native-spinkit SampleF8App https://github.com/fbsamples/f8app http://makeitopen.com/ Reading https://github.com/attentiveness/reading","categories":[{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tanjunze.github.io/tags/前端/"},{"name":"RN","slug":"RN","permalink":"https://tanjunze.github.io/tags/RN/"}]}]}