<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在Blog中添加背景图和动效]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%9C%A8Blog%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%92%8C%E5%8A%A8%E6%95%88%2F</url>
    <content type="text"><![CDATA[记录一次在Blog中添加动态效果。 参考网址：网站动态背景（动态图）和静态背景（背景图片）的主题美化 添加蜘蛛网动效需要在html页面的&lt;body&gt;&lt;/body&gt;标签中添加下面的js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;script type="text/javascript"&gt; ! function () &#123; function o(w, v, i) &#123; return w.getAttribute(v) || i &#125; function j(i) &#123; return document.getElementsByTagName(i) &#125; function l() &#123; var i = j("script"), w = i.length, v = i[w - 1]; return &#123; l: w, z: o(v, "zIndex", -1), //设置动态图显示的层位，一般-1就行，不用改 o: o(v, "opacity", 0.5), //0.5显示的是线条的透明度，可以自行调整 c: o(v, "color", "0,0,0"), //设置线条的颜色，三个0,0,0分别代表RGB颜色数值，不知道的可以打开PS里的拾色器就可以看到RGB数值了 n: o(v, "count", 120), //设置线条显示的数量，有密集恐惧症的朋友可别把数值设置太大哦 &#125; &#125; function k() &#123; r = u.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, n = u.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight &#125; function b() &#123; e.clearRect(0, 0, r, n); var w = [f].concat(t); var x, v, A, B, z, y; t.forEach(function (i) &#123; i.x += i.xa, i.y += i.ya, i.xa *= i.x &gt; r || i.x &lt; 0 ? -1 : 1, i.ya *= i.y &gt; n || i.y &lt; 0 ? -1 : 1, e.fillRect(i.x - 0.5, i.y - 0.5, 1, 1); for (v = 0; v &lt; w.length; v++) &#123; x = w[v]; if (i !== x &amp;&amp; null !== x.x &amp;&amp; null !== x.y) &#123; B = i.x - x.x, z = i.y - x.y, y = B * B + z * z; y &lt; x.max &amp;&amp; (x === f &amp;&amp; y &gt;= x.max / 2 &amp;&amp; (i.x -= 0.03 * B, i.y -= 0.03 * z), A = (x.max - y) / x.max, e.beginPath(), e.lineWidth = A / 2, e.strokeStyle = "rgba(" + s.c + "," + (A + 0.2) + ")", e.moveTo(i.x, i.y), e.lineTo(x.x, x.y), e.stroke()) &#125; &#125; w.splice(w.indexOf(i), 1) &#125;), m(b) &#125; var u = document.createElement("canvas"), s = l(), c = "c_n" + s.l, e = u.getContext("2d"), r, n, m = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (i) &#123; window.setTimeout(i, 1000 / 45) &#125;, a = Math.random, f = &#123; x: null, y: null, max: 20000 &#125;; u.id = c; u.style.cssText = "position:fixed;top:0;left:0;z-index:" + s.z + ";opacity:" + s.o; j("body")[0].appendChild(u); k(), window.onresize = k; window.onmousemove = function (i) &#123; i = i || window.event, f.x = i.clientX, f.y = i.clientY &#125;, window.onmouseout = function () &#123; f.x = null, f.y = null &#125;; for (var t = [], p = 0; s.n &gt; p; p++) &#123; var h = a() * r, g = a() * n, q = 2 * a() - 1, d = 2 * a() - 1; t.push(&#123; x: h, y: g, xa: q, ya: d, max: 6000 &#125;) &#125; setTimeout(function () &#123; b() &#125;, 100) &#125;();&lt;/script&gt; 添加背景图我的blog的样式有点差异，这记录一下。 在css样式文件中添加一下css:123456body&#123; width:100%; height:auto; background: url(背景图路径) no-repeat fixed; background-size: cover;&#125; 注意：背景图片最好是：1920x1080 背景图片素材网：Toptal 好了，通过以上2步操作就可以实现看的蜘蛛网效果 本blog使用hexo +material-x 搭建，body 标签文件在 &lt;hexo blog path&gt;\themes\material-x\layout\layout.ejsbody CSS文件在 &lt;hexo blog path&gt;\themes\material-x\source\less\_base.less中添加]]></content>
  </entry>
  <entry>
    <title><![CDATA[私有Dart Package Sever]]></title>
    <url>%2F2018%2F10%2F12%2FDart%20Package%20Server%2F</url>
    <content type="text"><![CDATA[搭建私有 Dart Package Server1、搭建Dart Package Server]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker命令笔记]]></title>
    <url>%2F2018%2F08%2F17%2FDocker%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、Docker 安装本示例采用sh脚本安装,其他方式参考Docker CE官网。 0、root用户登陆 1、升级yum包： $ sudo yum update 2、（可选）卸载旧的Docker $ sudo yum erase docker docker-common docker-client docker-compose 4、执行 Docker 安装脚本 $ curl -fsSL https://get.docker.com/ | sh或$ wget -qO- https://get.docker.com/ | sh 5、测试Docker $ docker info 6、设置Docker开机启动 $ sudo systemctl enable docker.service 7、开启Docker服务 $ sudo systemctl start docker 二、Docker Compose 安装 1、下载安装脚本 $ curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s-uname -m` -o /usr/local/bin/docker-compose 2、添加执行权限 $ chmod +x /usr/local/bin/docker-compose 三、Docker 常用命令 Docker 启动 $ sudo systemctl start docker docker 开机启动 $ sudo systemctl enable docker.service docker 当前容器开机启动 $ docker run -d –restart=always 容器终端 $ docker exec -it &lt;容器id&gt; /bin/bash 挂载目录 $ docker run -d -v &lt;主机目录路径&gt;:&lt;容器目录路径 &gt; 示例： $ docker run -d –restart=always -v /root/notebooks:/notebooks -it -p 8888:8888 tensorflow/tensorflow:latest-py3 拉取镜像 $ docker pull &lt;镜像tag&gt; 查看运行中的容器 $ docker ps 查看所有容器 $ docker ps -a 关闭容器 $ docker stop &lt;容器id&gt; 强制删除容器 $ docker rm -f &lt;容器id&gt; 查看镜像文件 $ docker images 删除镜像文件 docker rmi &lt;镜像id&gt; 参考文档 [1]、Docker CE [2]、Docker Compose [3]、Docker 常用命令与操作]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 整理]]></title>
    <url>%2F2018%2F07%2F13%2FFlutter%E6%95%B4%E7%90%862%2F</url>
    <content type="text"><![CDATA[Dart Packagehttps://www.dartlang.org/tools/pub 创建dart 包https://www.dartlang.org/guides/libraries/create-library-packages dart包依赖https://www.dartlang.org/tools/pub/dependencies#path-packages 依赖自建 pub serverhttps://www.dartlang.org/tools/pub/dependencies#hosted-packages 自建私有服务器Github： pub server 依赖Git仓库https://www.dartlang.org/tools/pub/dependencies#git-packages 本地仓库依赖https://www.dartlang.org/tools/pub/dependencies#path-packages Flutter Packagehttps://flutter.io/docs/development/packages-and-plugins/using-packages 开发Flutter包https://flutter.io/docs/development/packages-and-plugins/developing-packages]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android AIDL 原理]]></title>
    <url>%2F2018%2F06%2F18%2FAndroid%20AIDL%20%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android AIDL 原理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 整理]]></title>
    <url>%2F2018%2F06%2F05%2FFlutter%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[文档Flutter 官网 https://flutter.io/ Flutter 中文 官方：https://flutter-io.cn/ 社区：https://flutterchina.club/ Dart官网 https://www.dartlang.org/ Dart包管理 https://pub.dartlang.org/ https://pub.flutter-io.cn/ Flutter 桌面版 社区：https://github.com/google/flutter-desktop-embedding 其他：https://feather-apps.com/ codelabs中文：https://codelabs.flutter-io.cn/ 工具json_serializable https://caijinglong.github.io/json2dart/index_ch.html 动画 https://www.2dimensions.com/runtimes 博文闲鱼 https://www.yuque.com/xytech/flutter]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux笔记之ssh]]></title>
    <url>%2F2018%2F05%2F23%2Flinux%E7%AC%94%E8%AE%B0%E4%B9%8Bssh%2F</url>
    <content type="text"><![CDATA[1、ssh自动脚本登陆 1.1、创建shell脚本，如脚本 login.sh内容如下： 1234567#!/usr/bin/expect set timeout 3 spawn ssh user@192.168.3.24 expect "*password*" send "youPassword\r" interact 1.2、为自动登陆脚本添加执行权限，如： $ sudo chmod +x ./login.sh 1.3、（可选）为脚本添加别名 打开用户目录下的.bash_profile文件 $ vim ~/.bash_profile 添加 别名（如：SSLogin）和 脚本路径（如：/Users/youAccount/home/login.sh）保存并退出， 如： $ alias SSLogin=’/Users/youAccount/home/login.sh’ 刷新环境变量 $ source ~/.bash_profile 在终端中直接使用别名 SSLogin去登陆了,如 $ SSLogin 2、ssh免密码登陆 参考博文：SSH免密码登陆和免ip连接 参考网址： [1]、expect教程中文版 [2]、shell实现SSH自动登陆]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC命令]]></title>
    <url>%2F2018%2F05%2F22%2FMac%20%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Mac 命令打开关闭隐藏文件及目录1shift commond .]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派笔记之自动挂载nfts移动硬盘]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDnfts%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[0、插入ntfs的存储设备如：移动硬盘1、安装ntfs-3g $ sudo apt-get install ntfs-3g 2、查询外接存储目录权限和UUID $ ls -l /dev/disk/by-uuid/ 输出：1lrwxrwxrwx 1 root root 10 Jan 1 1970 0AC4D607C4D5F543 - &gt; ../../sda1 记下UUID - &gt; 0AC4D607C4D5F543的值 3、创建挂载点并赋权 $ sudo mkdir /mnt/usbdrive $ sudo chmod 770 /mnt/usbdrive 4、使用id命令获取uid，pi用户和组的gid（通常为1000） $ id -u pi $ id -g pi 5、挂载，然后检查/mnt/usbdrive是否可以访问它 $ sudo mount -t ntfs-3g -o uid=1000，gid=1000，umask=007 /dev/sda1/mnt/usbdrive 6、备份驱动目录并插入新的挂载点备份： $ sudo cp /etc/fstab /etc/fstab.backup 打开驱动目录文件并在最后一行写入新的驱动信息 $ sudo nano /etc/fstab 在fstab文件中添加安装信息（用您自己的UUID，uid，gid替换）：1UUID=0AC4D607C4D5F543 /mnt/usbdrive ntfs-3g uid=1000，gid=1000，umask=007 0 0 7、重新启动树莓派 sudo reboot 8、作为NextCloud的存储设备在/mnt/usbdrive驱动（移动硬盘）上配置NextCloud的数据目录，则它应该对www-data用户拥有770权限。您可以简单地将用户www-data添加到pi组中，因为它已经拥有770的权限，如上面在fstab中设置的那样。 $ sudo usermod -a -G pi www-data 参考网址： [1]、How to setup mount / auto-mount USB Hard Drive on Raspberry Pi [2]、NTFS External HD With ownCloud on the Raspberry Pi [3]、NTFS-3g HDD 0770 and 0777 permissions Owncloud [4]、通过 NextCloudPi 为树莓派可视化搭建 NextCloud 网盘（并折腾无语的 NTFS 移动硬盘） [5]、给树莓派挂载移动硬盘或U盘 [6]、树莓派Raspberry Pi 打造低成本NAS存储家庭服务器的十个问题整理]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派笔记之NextCloud安装]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%E4%B9%8BNextCloud%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Nextcloud 是一个免费专业的私有云存储网盘「开源」项目，可以让你简单快速地在个人/公司电脑、服务器甚至是树莓派等设备上架设一套属于自己或团队专属的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。 1、NextCloud简单安装的三种方式总结 1.1、使用 docker 安装：文档：https://github.com/nextcloud/docker 1.2、使用 nextcloud-snap 安装文档：https://github.com/nextcloud/nextcloud-snap 1.3 使用VM安装文档：https://github.com/nextcloud/vm NextCloud安装官方文档：https://nextcloud.com/install/#instructions-server 2、NextCloud在树莓派上的安装方式NextCloudPI官方文档：https://github.com/nextcloud/nextcloudpi 2.1、自己构建环境和部署NextCloud博文：在Raspberry Pi上简单安装Nextcloud 2.1、自动脚本构建NextCloud博文：在Raspberry Pi上自动安装Nextcloud 2.3、刷NextCloudPi镜像文件博文：树莓派Raspberry Pi安装NextCloud教程-自建家庭私有云局域网共享 2.4 使用 docker 安装：文档：NextCloudPI Github 3、NextCloud快速安装笔记 这里记录我目前使用的安装方式 步骤2.1中关键命令，方便查阅： 3.1、下载Ansible $ sudo apt-get -y install ansible 3.2、下载自动构建脚本 $ wget https://raw.githubusercontent.com/webtaster/Nextcloud/master/build_nextcloud.yml 3.3、(可选)使用 SQLite安装和配置Nextcloud $ sudo date ; ansible-playbook -s -c local -i “localhost,” build_nextcloud.yml 3.4、(可选)使用 MySQL安装和配置Nextcloud $ date ; ansible-playbook -s -c local -i “localhost,” –extra-vars “DATABASE=mysql MYSQL_ROOT_PASSWORD=qwerty NCUSER_PASSWORD=raindrop” build_nextcloud.yml 上面指令中MySQL用户密码（可以自定义）：用户：root 密码：qwerty 对应命令：MYSQL_ROOT_PASSWORD = qwerty用户：ncuser 密码：rainindrop 对应命令：NCUSER_PASSWORD = raindrop 3.5、初始化配置NextCloud在浏览器中打开 http://树莓派的IP地址/nextcloud 例如： http://192.168.1.99/nextcloud 然后根据NextCloud提示配置NextCloud就可以了。 3.6、(可选)配置树莓派目录读写权限如果在浏览器中配置NextCloud过程中错误提示“无法创建var/www/html/nextcloud/data“时，ssh等登陆树莓派并赋予775权限 $ sudo chmod -R 775 /var/www/html/nextcloud/]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派笔记之安装配置]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言： 这篇笔记记录不使用显示屏和网线来安装系统和配置环境 1、准备 树莓派3b+板子 SD存储卡和卡套 电源线和插头 路由器（有wifi就行） 2、刻录系统 2.1、到树莓派官网下载系统系统文件并解压 2.2、下载安装镜像刻录软件如：Mac版Etcher和window版win32diskimager等 2.3、插入SD卡到电脑并打开刻录软件如：目前使用的Etcher（示例） 2.3.1、选择（Select image）从官网下载并解压后的 NOOBS 或 RASPBIAN 镜像文件（ xxx.img 格式） 2.3.2、选择SD卡 (Select drive) 2.3.3 开始刻录镜像（Flash）并等待及几分钟至镜像刻录完成 3、配置wifi和ssh因为没有使用网线所以要在安装前配置好wifi和ssh，让板子在安装完系统后自动连接wifi并开启ssh。 3.1、配置wifi 打开SD卡，创建文件并写入保存：文件名：wpa_supplicant.conf 12345678910country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;ssid=&quot;mywifi&quot; #ssid（wifi名）psk=&quot;123456&quot; #password（wifi密码）key_mgmt=WPA-PSK #wifi加密方式priority=1 #优先级&#125; 3.2、配置ssh 打开SD卡，创建文件ssh文件(不写入内容，无后缀)文件名：ssh 4、安装系统并ssh登陆 4.1、将SD卡插入板子中并上电启动，如果绿灯不在闪烁且红灯常亮，那么系统安装并启动成功。 4.2、进入路由器查看名称为 raspberry设备的 IP地址，例如：设备：raspberry ，IP地址：192.168.1.56。如果没有查看到 raspberry设备和IP，请确认 步骤3.1 中文件 wpa_supplicant.conf是否正确配置wifi名称和密码。如果错误请重新刻录系统并配置wifi。 4.3、确认到 raspberry的IP（例如：192.168.1.56）后在电脑中打开终端（window使用xshell）连接到 Raspberry PI 板子的 ssh服务，例如： ssh pi@192.168.1.56 然后输入密码：raspberry(系统默认) 4.4、ssh登陆完成后就可以对板子操作了！ 5、设置wifi在板子断电或重启后自动连接网络 5.1、ssh登陆后执行 sudo nano /etc/network/interfaces 12345678910111213auto loiface lo inet loopbackiface eth0 inet dhcpallow-hotplug wlan0iface wlan0 inet dhcpwpa-ssid &quot;mywifi&quot;wpa-psk &quot;123456&quot; 保存退出 参考博文：Raspberry Pi树莓派无线网卡配置[多重方法备选] 6、安全管理 建议修改默认账户密码如： 用户：pi 密码：raspberry 注： 1、nano 编辑器 操作 退出：control x保存并退出： control o 保存 enter q确认 control x 退出 2、linxu c重启命令 sudo reboot 参考博文： [1]、树莓派如何完全无头(无屏无网线无键盘鼠标)安装 [2]、树莓派 - 修改pi账号密码,开启root账号 [3]、Raspberry Pi树莓派无线网卡配置[多重方法备选] [4]、NextCloud论坛]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用Android代理翻墙记录]]></title>
    <url>%2F2018%2F05%2F17%2FMac%E4%BD%BF%E7%94%A8Android%E4%BB%A3%E7%90%86%E7%BF%BB%E5%A2%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1、下载Proxy Server代理软件2、创建一个代理服务（Proxy Server） 3、设置服务名和端口并返回后点击Start按钮启动服务 4、打开FireFox浏览器并配置网络代理 5、设置启动代理服务手机的Ip和上面填写端口 到此 FireFox 可以使用手机的代理服务，如果手机已经翻墙了，那么FireFox就可以实现翻墙。 同样可以为电脑设置代理配置，实现全局代理。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习资料整理]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[我的机器学习资料，为了方便查询同步到笔记中。 机器学习资料文档资料 深度学习资料-Github 神经网络和深度学习•Michael Nielsen 神经网络和深度学习•Michael Nielsen（翻译） 深度学习•Bengio 深度学习•Bengio（翻译） Tensorflow官网-国内 Tensorflow社区-国内 深度学习资料整理1-国内 深度学习路线图 深度学习博文 深度学习Java框架 在线教育 Google深度学习-Udacity课程 Google机器学习速成课程 深度学习-Stanford-UFLDL 深度学习-Stanford-Tutorial 人工智能实践：Tensorflow笔记-慕课网 莫烦Python 工具 python jupyter notebook 框架 Tensorflow Tensorflow（极客学院-翻译） TensorLayer-中文 TensorLayer scikit-learn scikit-learn 翻译 caffe 或 caffe2 Keras keras 翻译 theano … 其他文档 Deepmind 积卷神经网络-斯坦福 Siraj Raval-Gitub-Youtube CS231n课程-积卷网络 CS231n课程-积卷网络-中文翻译 深度学习-开源项目 音频合成-Merlin 音频合成-Wavenet 深度学习-Udacity-Code 无人驾驶-BehavioralCloning) 无人驾驶-udacity-sim 无人驾驶-CSDN博文 机器学习数据集 机器学习数据集1-知乎提问 机器学习数据集2-知乎博文]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 之旅]]></title>
    <url>%2F2018%2F03%2F22%2FDart%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[dartpad 特性 所有的变量引用都是对象，每个对象都是一个类的实例。在Dart 中甚至 数字（numbers）、方法（functions）和null都是对象。所有对象都继承Object类。 尽管Dart 是强类型语言，但是类型声明是可选的，因为Dart可以推断类型。如果要明确说明不需要任何类型， 则使用特殊类型dynamic。 Dart 支持泛型，例如List 或List。 Dart 支持顶级方法（如main()），静态方法，实例方法和方法内方法（嵌套函数和本地函数）。 Dart 支持顶级变量，以及类中定义变量（静态变量和实例变量）。实例变量有时称为字段和属性。 与Java不同的是，Dart 中没有public,private,protected关键字，如果标识符已（_）开头，则其是私有的。 标识符可以以字母或下划线（_）开头，后跟这些字符加数字的任意组合。 Dart有两个表达式（具有运行时值）和 语句（不具有）。例如，条件表达式 condition ? expr1 : expr2的值为expr1或expr2。将其与if-else语句进行比较，该语句没有任何值。语句通常包含一个或多个表达式，但表达式不能直接包含语句。 Dart工具可以报告两种问题：警告和错误。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误会阻止代码执行; 运行时错误导致 代码执行时引发异常。 变量12var name='Bob';dynamic name = 'Bob' ; 默认值未初始化的变量默认为null。 1int lineCount ; assert （lineCount == null ）; final 和 const如果不打算修改一个变量，使用final或const,final 修饰的变量只能赋值一次；一个const变量是编译时常量。（const变量同时也是final变量。）顶级的final 变量或类中的final变量在第一次使用时初始化。 12345678910final name = 'Bob'; final String nickname = 'Bobby';const bar = 1000000；const double atm = 1.01325 * bar;var foo = const [];final bar = const [];const baz = []; // 等价于`const []`foo = [1, 2, 3]; // const []baz = [42]; // 错误 不能赋值 内置类型number123456789101112131415161718192021222324252627282930// int 类型var x = 1 ;var hex = 0xDEADBEEF ; // double 类型var y = 1.1 ; var exponents = 1.42e5 ; double z = 1 ; //相当于double z = 1.0。 // 类型转换// String -&gt; intvar one = int.parse('1');assert(one == 1);// String -&gt; doublevar onePointOne = double.parse('1.1');assert(onePointOne == 1.1);// int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == '1');// double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == '3.14');assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001assert((3 | 4) == 7); // 0011 | 0100 == 0111const msPerSecond = 1000;const secondsUntilRetry = 5;const msUntilRetry = secondsUntilRetry * msPerSecond; StringDart String 是UTF-16编码，可以使用&#39;或&quot; 1234var s1 = 'Single quotes work well for string literals.';var s2 = "Double quotes work just as well.";var s3 = 'It\'s easy to escape the string delimiter.';var s4 = "It's even easier to use the other delimiter."; 字符串拼接 1234567891011121314151617181920212223242526272829303132333435var s = 'string interpolation';assert('Dart has $s, which is very handy.' == 'Dart has string interpolation, ' + 'which is very handy.'); // trueassert('That deserves all caps. ' + '$&#123;s.toUpperCase()&#125; is very handy!' == 'That deserves all caps. ' + 'STRING INTERPOLATION is very handy!'); // truevar s1 = 'String ' 'concatenation' " works even over line breaks.";assert(s1 == 'String concatenation works even over ' 'line breaks.'); // truevar s2 = 'The + operator ' + 'works, as well.';assert(s2 == 'The + operator works, as well.'); // truevar s = r'In a raw string, not even \n gets special treatment.';// These work in a const string.const aConstNum = 0;const aConstBool = true;const aConstString = 'a constant string';// These do NOT work in a const string.var aNum = 0;var aBool = true;var aString = 'a string';const aConstList = [1, 2, 3];const validConstString = '$aConstNum $aConstBool $aConstString';// const invalidConstString = '$aNum $aBool $aString $aConstList'; Booleans123456789101112131415// Check for an empty string.var fullName = '';assert(fullName.isEmpty);// Check for zero.var hitPoints = 0;assert(hitPoints &lt;= 0);// Check for null.var unicorn;assert(unicorn == null);// Check for NaN.var iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); List12345678910var list = [1, 2, 3];var list = [1, 2, 3];assert(list.length == 3);assert(list[1] == 2);list[1] = 1;assert(list[1] == 1);var constantList = const [1, 2, 3];// constantList[1] = 1; // Uncommenting this causes an error. Maps12345678910111213141516171819202122232425262728293031323334353637383940414243var gifts = &#123; // Key: Value 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings'&#125;;var nobleGases = &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;var gifts = Map();gifts['first'] = 'partridge';gifts['second'] = 'turtledoves';gifts['fifth'] = 'golden rings';var nobleGases = Map();nobleGases[2] = 'helium';nobleGases[10] = 'neon';nobleGases[18] = 'argon';var gifts = &#123;'first': 'partridge'&#125;;gifts['fourth'] = 'calling birds'; // Add a key-value pairvar gifts = &#123;'first': 'partridge'&#125;;assert(gifts['first'] == 'partridge');var gifts = &#123;'first': 'partridge'&#125;;assert(gifts['fifth'] == null);var gifts = &#123;'first': 'partridge'&#125;;gifts['fourth'] = 'calling birds';assert(gifts.length == 2);// truefinal constantMap = const &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;// constantMap[2] = 'Helium'; // Uncommenting this causes an error. Runes表达Unicode代码的常用方法是 \uXXXX，其中XXXX是4位十六进制值。例如，心脏（♥）是\u2665。要是多于或少于4个十六进制数字，将值放在大括号中。例如，笑表情符号（😆）是\u{1f600}。 1234567891011121314main() &#123; var clapping = '\u&#123;1f44f&#125;'; print(clapping); print(clapping.codeUnits); print(clapping.runes.toList()); // 👏 //[55357, 56399] //[128079] Runes input = new Runes( '\u2665 \u&#123;1f605&#125; \u&#123;1f60e&#125; \u&#123;1f47b&#125; \u&#123;1f596&#125; \u&#123;1f44d&#125;'); print(new String.fromCharCodes(input)); // ♥ 😅 😎 👻 🖖 👍&#125; 方法1234bool isNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125;bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null; 可选参数可选参数可以是命名参数或者基于位置的参数，但是这两种参数不能同时当做可选参数。 Optional named parameters（可选命名参数）调用函数时，可以使用指定命名参数 。例如：*paramName*: *value* 1enableFlags （bold ：true ，hidden ：false ）; 定义函数时，用于 {param1, param2, …}指定命名参数。 1void enableFlags(&#123;bool bold, bool hidden&#125;) &#123;...&#125; Optional positional parameters（可选位置参数）把一些方法的参数放到 [] 中就变成可选 位置参数了： 1234567891011String say(String from, String msg, [String device]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; return result;&#125;assert(say('Bob', 'Howdy') == 'Bob says Howdy'); //trueassert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal');// true Default parameter values（默认参数值）12345678910111213141516171819202122232425262728293031/// Sets the [bold] and [hidden] flags ...void enableFlags(&#123;bool bold = false, bool hidden = false&#125;) &#123;...&#125;// bold will be true; hidden will be false.enableFlags(bold: true);String say(String from, String msg, [String device = 'carrier pigeon', String mood]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; if (mood != null) &#123; result = '$result (in a $mood mood)'; &#125; return result;&#125;assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');void doStuff( &#123;List&lt;int&gt; list = const [1, 2, 3], Map&lt;String, String&gt; gifts = const &#123; 'first': 'paper', 'second': 'cotton', 'third': 'leather' &#125;&#125;) &#123; print('list: $list'); print('gifts: $gifts');&#125;]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android AIDL 使用]]></title>
    <url>%2F2018%2F02%2F26%2FAndroid%20AIDL%20%E4%B8%80%20%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%20%2F</url>
    <content type="text"><![CDATA[Android AIDLAIDL：Android Interface Definition Language 。用于IPC （Inter-Process Communication，进程间通信），如 多应用间的通信，应用中存在多进程间的通信等场景。 只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口 一、定义AIDL接口1、创建 .aidl 文件在src 文件夹内创建IRemoteService.aidl 文件，如下。编译工程，此时会在创建相同名称的 IRemoteService.java文件。 12345678910111213141516// IRemoteService.aidlpackage com.example.android;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService &#123; /** Request the process ID of this service, to do evil things with it. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 2、实现.aidl生成的.java接口123456789private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125;&#125;; 3、公开接口12345678910111213141516171819202122public class RemoteService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; // Return the interface return mBinder; &#125; private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does nothing &#125; &#125;;&#125; 二、通过IPC 传递对象IPC 中传递的对象需要实现 Parcelable 接口 ，例如 Rect.aidl 文件可创建一个可打包的 Rect 类： 12345package android.graphics;// Declare Rect so AIDL can find it and knows that it implements// the parcelable protocol.parcelable Rect; 1234567891011121314151617181920212223242526272829303132333435363738394041import android.os.Parcel;import android.os.Parcelable;public final class Rect implements Parcelable &#123; public int left; public int top; public int right; public int bottom; public static final Parcelable.Creator&lt;Rect&gt; CREATOR = newParcelable.Creator&lt;Rect&gt;() &#123; public Rect createFromParcel(Parcel in) &#123; return new Rect(in); &#125; public Rect[] newArray(int size) &#123; return new Rect[size]; &#125; &#125;; public Rect() &#123; &#125; private Rect(Parcel in) &#123; readFromParcel(in); &#125; public void writeToParcel(Parcel out) &#123; out.writeInt(left); out.writeInt(top); out.writeInt(right); out.writeInt(bottom); &#125; public void readFromParcel(Parcel in) &#123; left = in.readInt(); top = in.readInt(); right = in.readInt(); bottom = in.readInt(); &#125;&#125; 三、 调用 IPC 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public static class Binding extends Activity &#123; /** The primary interface we will be calling on the service. */ IRemoteService mService = null; /** Another interface we use on the service. */ ISecondary mSecondaryService = null; Button mKillButton; TextView mCallbackText; private boolean mIsBound; /** * Standard initialization of this activity. Set up the UI, then wait * for the user to poke it before doing anything. */ @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.remote_service_binding); // Watch for button clicks. Button button = (Button)findViewById(R.id.bind); button.setOnClickListener(mBindListener); button = (Button)findViewById(R.id.unbind); button.setOnClickListener(mUnbindListener); mKillButton = (Button)findViewById(R.id.kill); mKillButton.setOnClickListener(mKillListener); mKillButton.setEnabled(false); mCallbackText = (TextView)findViewById(R.id.callback); mCallbackText.setText("Not attached."); &#125; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the service object we can use to // interact with the service. We are communicating with our // service through an IDL interface, so get a client-side // representation of that from the raw service object. mService = IRemoteService.Stub.asInterface(service); mKillButton.setEnabled(true); mCallbackText.setText("Attached."); // We want to monitor the service for as long as we are // connected to it. try &#123; mService.registerCallback(mCallback); &#125; catch (RemoteException e) &#123; // In this case the service has crashed before we could even // do anything with it; we can count on soon being // disconnected (and then reconnected if it can be restarted) // so there is no need to do anything here. &#125; // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_connected, Toast.LENGTH_SHORT).show(); &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mKillButton.setEnabled(false); mCallbackText.setText("Disconnected."); // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_disconnected, Toast.LENGTH_SHORT).show(); &#125; &#125;; /** * Class for interacting with the secondary interface of the service. */ private ServiceConnection mSecondaryConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // Connecting to a secondary interface is the same as any // other interface. mSecondaryService = ISecondary.Stub.asInterface(service); mKillButton.setEnabled(true); &#125; public void onServiceDisconnected(ComponentName className) &#123; mSecondaryService = null; mKillButton.setEnabled(false); &#125; &#125;; private OnClickListener mBindListener = new OnClickListener() &#123; public void onClick(View v) &#123; // Establish a couple connections with the service, binding // by interface names. This allows other applications to be // installed that replace the remote service by implementing // the same interface. Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); intent.setAction(ISecondary.class.getName()); bindService(intent, mSecondaryConnection, Context.BIND_AUTO_CREATE); mIsBound = true; mCallbackText.setText("Binding."); &#125; &#125;; private OnClickListener mUnbindListener = new OnClickListener() &#123; public void onClick(View v) &#123; if (mIsBound) &#123; // If we have received the service, and hence registered with // it, then now is the time to unregister. if (mService != null) &#123; try &#123; mService.unregisterCallback(mCallback); &#125; catch (RemoteException e) &#123; // There is nothing special we need to do if the service // has crashed. &#125; &#125; // Detach our existing connection. unbindService(mConnection); unbindService(mSecondaryConnection); mKillButton.setEnabled(false); mIsBound = false; mCallbackText.setText("Unbinding."); &#125; &#125; &#125;; private OnClickListener mKillListener = new OnClickListener() &#123; public void onClick(View v) &#123; // To kill the process hosting our service, we need to know its // PID. Conveniently our service has a call that will return // to us that information. if (mSecondaryService != null) &#123; try &#123; int pid = mSecondaryService.getPid(); // Note that, though this API allows us to request to // kill any process based on its PID, the kernel will // still impose standard restrictions on which PIDs you // are actually able to kill. Typically this means only // the process running your application and any additional // processes created by that app as shown here; packages // sharing a common UID will also be able to kill each // other's processes. Process.killProcess(pid); mCallbackText.setText("Killed service process."); &#125; catch (RemoteException ex) &#123; // Recover gracefully from the process hosting the // server dying. // Just for purposes of the sample, put up a notification. Toast.makeText(Binding.this, R.string.remote_call_failed, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125;; // ---------------------------------------------------------------------- // Code showing how to deal with callbacks. // ---------------------------------------------------------------------- /** * This implementation is used to receive callbacks from the remote * service. */ private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() &#123; /** * This is called by the remote service regularly to tell us about * new values. Note that IPC calls are dispatched through a thread * pool running in each process, so the code executing here will * NOT be running in our main thread like most other things -- so, * to update the UI, we need to use a Handler to hop over there. */ public void valueChanged(int value) &#123; mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0)); &#125; &#125;; private static final int BUMP_MSG = 1; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BUMP_MSG: mCallbackText.setText("Received from service: " + msg.arg1); break; default: super.handleMessage(msg); &#125; &#125; &#125;;&#125; 参考： [1]、Android AIDL]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ContentProvider]]></title>
    <url>%2F2018%2F01%2F26%2FAndroid%20ContentProvider%2F</url>
    <content type="text"><![CDATA[Android ContentProviderContentProvider（内容提供者）作为Android 四大组件之一主要用于为为其他应用提供复杂的数据或文件。 内容 URI是ContentProvider 的唯一表示,app 根据您 内容uri 查询操作数据。内容uri的结构如下： 1content://authority/tablename/id 标识 说明 content ContentProvider 前缀标识 authority 授权：指定内容提供者的名称，如：com.hello.provider tablename 需要访问数据的名称，一般为数据库表名 如：user id 数据表下 id 表示的行,如：1 示例：content://com.hello.provider/user/1 访问 com.hello.provider数据user 表中1表示的行。 内容url 的通配符 ​ *：匹配由任意长度的任何有效字符组成的字符串 ​ #：匹配由任意长度的数字字符组成的字符串 创建内容提供者1、实现ContentProvider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class BookProvider extends ContentProvider &#123; private static final String TAG = "BookProvider"; public static final String AUTHORITY = "com.ryg.chapter_2.book.provider"; public static final Uri BOOK_CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/book"); public static final Uri USER_CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/user"); public static final int BOOK_URI_CODE = 0; public static final int USER_URI_CODE = 1; private static final UriMatcher sUriMatcher = new UriMatcher( UriMatcher.NO_MATCH); static &#123; sUriMatcher.addURI(AUTHORITY, "book", BOOK_URI_CODE); sUriMatcher.addURI(AUTHORITY, "user", USER_URI_CODE); &#125; private Context mContext; private SQLiteDatabase mDb; @Override public boolean onCreate() &#123; Log.d(TAG, "onCreate, current thread:" + Thread.currentThread().getName()); mContext = getContext(); initProviderData(); return true; &#125; private void initProviderData() &#123; mDb = new DbOpenHelper(mContext).getWritableDatabase(); mDb.execSQL("delete from " + DbOpenHelper.BOOK_TABLE_NAME); mDb.execSQL("delete from " + DbOpenHelper.USER_TALBE_NAME); mDb.execSQL("insert into book values(3,'Android');"); mDb.execSQL("insert into book values(4,'Ios');"); mDb.execSQL("insert into book values(5,'Html5');"); mDb.execSQL("insert into user values(1,'jake',1);"); mDb.execSQL("insert into user values(2,'jasmine',0);"); &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; Log.d(TAG, "query, current thread:" + Thread.currentThread().getName()); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; return mDb.query(table, projection, selection, selectionArgs, null, null, sortOrder, null); &#125; @Override public String getType(Uri uri) &#123; Log.d(TAG, "getType"); return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; Log.d(TAG, "insert"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; mDb.insert(table, null, values); mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; Log.d(TAG, "delete"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; int count = mDb.delete(table, selection, selectionArgs); if (count &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; Log.d(TAG, "update"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; int row = mDb.update(table, values, selection, selectionArgs); if (row &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return row; &#125; private String getTableName(Uri uri) &#123; String tableName = null; switch (sUriMatcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = DbOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = DbOpenHelper.USER_TALBE_NAME; break; default:break; &#125; return tableName; &#125;&#125; 注册 ContentProvider 1234&lt;provider android:name=".provider.BookProvider" android:authorities="com.ryg.chapter_2.book.provider" &gt;&lt;/provider&gt; 2、调用ContentProvider12345678910111213141516171819202122232425262728293031323334public class ProviderActivity extends Activity &#123; private static final String TAG = "ProviderActivity"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_provider); Uri bookUri = Uri.parse("content://com.ryg.chapter_2.book.provider/book"); ContentValues values = new ContentValues(); values.put("_id", 6); values.put("name", "程序设计的艺术"); getContentResolver().insert(bookUri, values); Cursor bookCursor = getContentResolver().query(bookUri, new String[]&#123;"_id", "name"&#125;, null, null, null); while (bookCursor.moveToNext()) &#123; Book book = new Book(); book.bookId = bookCursor.getInt(0); book.bookName = bookCursor.getString(1); Log.d(TAG, "query book:" + book.toString()); &#125; bookCursor.close(); Uri userUri = Uri.parse("content://com.ryg.chapter_2.book.provider/user"); Cursor userCursor = getContentResolver().query(userUri, new String[]&#123;"_id", "name", "sex"&#125;, null, null, null); while (userCursor.moveToNext()) &#123; User user = new User(); user.userId = userCursor.getInt(0); user.userName = userCursor.getString(1); user.isMale = userCursor.getInt(2) == 1; Log.d(TAG, "query user:" + user.toString()); &#125; userCursor.close(); &#125;&#125; 3、添加自定义权限ContentProvider 可以自定义权限来限制 数据共享的应用， 自定义权限：https://developer.android.com/guide/topics/manifest/permission-element.html 参考： [1]、Android ContentProvider [2]、Android Permission [3]、《Android开发艺术探索》]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android FragmentPageAdapter 与 FragmentStatePageAdapter]]></title>
    <url>%2F2017%2F12%2F05%2FFragmentPageAdapter%2F</url>
    <content type="text"><![CDATA[FragmentPageAdapter 与 FragmentStatePageAdapter在项目中需要动态更新Tab，于是对于选择FragmentPageAdapter和FragmentStatePageAdapter有点困惑。几经周转总算理解了，这里记录一下。当然有问题是的时候还是看官方文档比较详细。 FragmentPageAdapter官网：https://developer.android.com/reference/android/support/v4/app/FragmentPagerAdapter.html 文档中描述了FragmentPageAdapter中每一个Fragment都将保存在内存，所以FragmentPagerAdapter适合那些相数量相对较少，静态的页面。对于存在多个fragment的情况，一般推荐使用FragmentStatePagerAdapter。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class FragmentPagerSupport extends FragmentActivity &#123; static final int NUM_ITEMS = 10; MyAdapter mAdapter; ViewPager mPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.fragment_pager); mAdapter = new MyAdapter(getSupportFragmentManager()); mPager = (ViewPager)findViewById(R.id.pager); mPager.setAdapter(mAdapter); // Watch for button clicks. Button button = (Button)findViewById(R.id.goto_first); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mPager.setCurrentItem(0); &#125; &#125;); button = (Button)findViewById(R.id.goto_last); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mPager.setCurrentItem(NUM_ITEMS-1); &#125; &#125;); &#125; public static class MyAdapter extends FragmentPagerAdapter &#123; public MyAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public int getCount() &#123; return NUM_ITEMS; &#125; @Override public Fragment getItem(int position) &#123; return ArrayListFragment.newInstance(position); &#125; &#125; public static class ArrayListFragment extends ListFragment &#123; int mNum; /** * Create a new instance of CountingFragment, providing "num" * as an argument. */ static ArrayListFragment newInstance(int num) &#123; ArrayListFragment f = new ArrayListFragment(); // Supply num input as an argument. Bundle args = new Bundle(); args.putInt("num", num); f.setArguments(args); return f; &#125; /** * When creating, retrieve this instance's number from its arguments. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mNum = getArguments() != null ? getArguments().getInt("num") : 1; &#125; /** * The Fragment's UI is just a simple text view showing its * instance number. */ @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_pager_list, container, false); View tv = v.findViewById(R.id.text); ((TextView)tv).setText("Fragment #" + mNum); return v; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), android.R.layout.simple_list_item_1, Cheeses.sCheeseStrings)); &#125; @Override public void onListItemClick(ListView l, View v, int position, long id) &#123; Log.i("FragmentList", "Item clicked: " + id); &#125; &#125;&#125; R.layout.fragment_pager 1234567891011121314151617181920212223242526&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:padding="4dip" android:gravity="center_horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/pager" android:layout_width="match_parent" android:layout_height="0px" android:layout_weight="1"&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;LinearLayout android:orientation="horizontal" android:gravity="center" android:measureWithLargestChild="true" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="0"&gt; &lt;Button android:id="@+id/goto_first" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/first"&gt; &lt;/Button&gt; &lt;Button android:id="@+id/goto_last" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/last"&gt; &lt;/Button&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; R.layout.fragment_pager_list 123456789101112131415161718192021222324252627282930313233343536&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@android:drawable/gallery_thumb"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center_vertical|center_horizontal" android:textAppearance="?android:attr/textAppearanceMedium" android:text="@string/hello_world"/&gt; &lt;!-- The frame layout is here since we will be showing either the empty view or the list view. --&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="0dip" android:layout_weight="1" &gt; &lt;!-- Here is the list. Since we are using a ListActivity, we have to call it "@android:id/list" so ListActivity will find it --&gt; &lt;ListView android:id="@android:id/list" android:layout_width="match_parent" android:layout_height="match_parent" android:drawSelectorOnTop="false"/&gt; &lt;!-- Here is the view to show if the list is emtpy --&gt; &lt;TextView android:id="@android:id/empty" android:layout_width="match_parent" android:layout_height="match_parent" android:textAppearance="?android:attr/textAppearanceMedium" android:text="No items."/&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; FragmentStatePageAdapter官网：https://developer.android.com/reference/android/support/v4/app/FragmentPagerAdapter.html FragmentStatePageAdapter 在适合像listView大量page的场景。当page不显示的时候fragment可能被销毁，此时fragment的状态会保存起来，相比FragmentPageAdapter占用内存较少。但是在 page 切换时fragment 再次创建会产生额外的开销。 123456789101112131415public static class MyAdapter extends FragmentStatePagerAdapter &#123; public MyAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public int getCount() &#123; return NUM_ITEMS; &#125; @Override public Fragment getItem(int position) &#123; return ArrayListFragment.newInstance(position); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Handle 消息机制]]></title>
    <url>%2F2017%2F12%2F02%2FAndroid%20handle%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android Handle 消息机制handle 消息机制是Android 重要的组成部分，首先我们需要的理解的是Android为什么需要 handle 机制。开发Android的都得知道 Android有主线程之分（UI 线程），主线程中每16ms接收到Android系统的同步信号来更新UI 视图。如果在主线程中进行耗时操作会阻塞线性会造成ANR（无响应异常）。如果在子线程中进行耗时操作，当子线程任务完成时，无法直接调用主线程中UI 组件（主线程不是线程安全的，子线直接调用主线程中的UI 组件会产生不可预期的错误，如死锁等，如果给主线程加锁会造成UI 组件的复杂性并且阻塞了部分操作的执行）。基于以上的理由Android 设计了Handle 机制来确保当子线程执行完耗时操作时能够安全的更新主线程中的UI 视图（也可以确保不同线程之间的安全通信）。到这里我们能够理解 handle 机制 机制存在的理由了，下面我们继续组成、使用及原理。 如上图，Handle 中有三个重要的组成部分：handle，Loop，MessageQueue。 Handle在Handle主要承担着发送Message 到 MessageQueue队列中和和接收处理 Loop 分发过来的 Message。 如下代码 1234567891011121314151617181920212223242526public class HandleExample &#123; Handler mHandler; public static final int HANDLE_WHAT_1 = 10; public void HandleExample() &#123; mHandler = new Handler(Looper.getMainLooper()) &#123; // 接收 Loop 分发的 Message @Override public void handleMessage(Message message) &#123; switch (message.what) &#123; case HANDLE_WHAT_1: break; default: break; &#125; &#125; &#125;; Message message = new Message(); message.what = HANDLE_WHAT_1; message.arg1 = 1; message.arg2 = 2; message.obj = "handle test"; // 发送 消息 mHandler.sendMessage(message); &#125;&#125; 在源代码中 handle 通过 send***方法调用MessageQueue的queue.enqueueMessage向 MessageQueue插入一条Message 1234567891011121314151617181920// 源码 Handler.java public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 在Loop调用 MessageQueue中的 getNextMessage 方法 获取 Message的handle 引用 通过 dispatchMessage分发Handle 中处理。 12345678910111213141516// 源码 while (SystemClock.uptimeMillis() &lt; end) &#123; boolean conditionsMet = true; // 省略部分代码 if (conditionsMet) &#123; QueueState queueState = queueInterrogator.determineQueueState(); if (queueState == QueueState.EMPTY || queueState == QueueState.TASK_DUE_LONG) &#123; return; &#125; &#125; Message message = queueInterrogator.getNextMessage(); message.getTarget().dispatchMessage(message); recycler.recycle(message); loopCount++; &#125; MessageQueue单链表结构，主要用于存储 Message, 插入方法enqueueMessage,出队方法 next , LoopLoop 主要是一个循环器，它不断的循环 MessageQueue 队列并取出 Message 交个 Handle处理。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Service 二 组件间通信]]></title>
    <url>%2F2017%2F11%2F14%2FAndroid%20Service%20%E4%BA%8C%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Android Service 通信Android 中 Service 通信需要使用 bindService启动方式，但是startService启动方式 也可以与组件间进行通信。这里总结 Service 通信方式。 startService1、使用广播通信不推荐此种方式 广播发送： 1234Intent intent = new Intent();intent.putExtra("paramkey1","params1");intent.setAction(RECEIVER_ACTION); LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent); 广播接收： 12345private BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // todo&#125; 2、EventBus 通信eventbus：https://github.com/greenrobot/EventBus 发送消息： 12345678910111213141516@Overridepublic void onStart() &#123; super.onStart(); EventBus.getDefault().register(this);&#125;@Overridepublic void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this);&#125;public void sendComponentMessage()&#123; // 发送消息 EventBus.getDefault().post(new MessageEvent());&#125; 接收消息： 1234@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(MessageEvent event) &#123; Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();&#125; bindService只有 Activity、服务和内容提供程序可以绑定到服务 — 无法从广播接收器绑定到服务。 1、 IBinder 通信 注：此方法只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效。 之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方法不执行任何跨进程编组。 1234567891011121314151617181920public class LocalService extends Service &#123; private final IBinder mBinder = new LocalBinder(); private final Random mGenerator = new Random(); public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class BindingActivity extends Activity &#123; LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125; /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) &#123; if (mBound) &#123; // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, "number: " + num, Toast.LENGTH_SHORT).show(); &#125; &#125; /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; // We've bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mBound = false; &#125; &#125;;&#125; 2、Messenger 通信 相对于 AIDL 当您需要执行 IPC 时，为您的接口使用 Messenger 要比使用 AIDL 实现它更加简单，因为 Messenger 会将所有服务调用排入队列，而纯粹的 AIDL 接口会同时向服务发送多个请求，服务随后必须应对多线程处理。 1234567891011121314151617181920212223242526272829303132333435public class MessengerService extends Service &#123; /** Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ class IncomingHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_SAY_HELLO: Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; /** * Target we publish for clients to send messages to IncomingHandler. */ final Messenger mMessenger = new Messenger(new IncomingHandler()); /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) &#123; Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show(); return mMessenger.getBinder(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ActivityMessenger extends Activity &#123; /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean mBound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); mBound = true; &#125; public void onServiceDisconnected(ComponentName className) &#123; // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; mBound = false; &#125; &#125;; public void sayHello(View v) &#123; if (!mBound) return; // Create and send a message to the service, using a supported 'what' value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125; @Override protected void onStart() &#123; super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onStop() &#123; super.onStop(); // Unbind from the service if (mBound) &#123; unbindService(mConnection); mBound = false; &#125; &#125;&#125; 3、AIDL 通信Android AIDL 一 基本使用 参考： [1]、android 绑定服务]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Frp内网穿透笔记]]></title>
    <url>%2F2017%2F11%2F02%2FFrp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[https://github.com/fatedier/frp/issues/176]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo/GitHub Pages搭建个人博客]]></title>
    <url>%2F2017%2F10%2F05%2FHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言好久没有在github pages 中更新笔记了，刚把旧的github仓库重新整理了。在此记录一下，日后逐渐将旧笔记往这里迁移。 1、配置环境Hexo官方文档: Hexo wiki 首先安装: Node.js Git 再安装 Hexo1$ npm install -g hexo-cli 到此Hexo安装完成，如果失败请参考官网，这里只记录简单流程。 2、搭建站点执行命令：123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 3、配置站点打开 folder/_config.yml 文件修改配置即可 4、启动服务1$ hexo server 简写1$ hexo s 此时控制台中打印出 http://localhost:4000/ ,再使用浏览器打开你就可以看到Hello world页面了。 5、发布到github上参考：Hexo 部署 注意：首先你需要创建github账户，gtihub的仓库并push、pull仓库已验证你的github配置完成。 再创建一个仓库命名为&lt;你的用户名&gt;.github.io,如： tanjunze.github.io 打开本地&lt;folder&gt; Hexo工程安装 hexo-deployer-git123cd &lt;folder&gt;npm install hexo-deployer-git --save 打开本地folder/_config.yml找到Deployment选项，并修改：其中将repo改为1git@github.com:&lt;你的账户名&gt;/&lt;你的账户名&gt;.github.io.git 执行1hexo deploy 如果push成功，打开https://&lt;你的用户名&gt;.github.io,例如： https://tanjunze.github.io/ 恭喜你成功搭建了在Hexo + Gtihub Pages 的个人免费站点了。 参考网址：http://www.cnblogs.com/zhcncn/p/4097881.html]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Service 一]]></title>
    <url>%2F2017%2F10%2F02%2FAndroid%20Service%20%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Android ServiceService 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。 一、Service 启动方式Service有2种启动方式： 1、startService12Intent intent = new Intent(this, HelloService.class);startService(intent); 当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。 2、bindSevice12Intent intent = new Intent(this, LocalService.class);bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE); 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在服务终止的情况下继续运行服务（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改）。从 onStartCommand() 返回的值必须是以下常量之一： 1、 START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。 2、 START_STICKY 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。 3、 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 二、Service的生命周期 三、IntentServiceIntentService是 Service 的子类，它通过工作队列的形式处理任务。当任务完成时自动stopSelf() IntentService 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 四、前台服务前台服务(foreground service)可以简单理解为状态栏提供通知的服务，当一个服务为前台服务时，即使系统在在内存不足时，系统也不会考虑将其终止 创建前台服务需要在Service中提供状态栏通知，并调用startForeground())，例： 123456Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text),System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification); 五、扩展知识IntentServieJobIntentServicebinderServiceAsyncTaskHandlerThread参考： [1]、android services]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android手机搭建Linux环境]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E6%89%8B%E6%9C%BA%E6%90%AD%E5%BB%BALinux%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Termux介绍 Termux是Android，Chromebook和Fire OS的终端模拟器和Linux环境。官网：https://wiki.termux.comgithub：https://github.com/termux/termux-app 1、配置Termux。1.1 升级 apt(否则无法安装软件)1apt update 1.2 安装openssh1apt intall openssh]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传本地文件到远程linux主机]]></title>
    <url>%2F2017%2F09%2F02%2F%E5%9C%A8markdown%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在markdown中插入数学公式的方法1、使用codecogsAPIcodecogs可以支持多种格式如：gif、png、pdf、swf、emf、svg。(推荐svg格式)12345http://latex.codecogs.com/gif.latex?公式 http://latex.codecogs.com/svg.latex?公式http://latex.codecogs.com/png.latex?公式 例如要显示下面的公式： 的公式为 \frac{1}{1+sin(x)} &gt;在文本中插入如下 1![](http://latex.codecogs.com/svg.latex?\frac&#123;1&#125;&#123;1+sin(x)&#125;) }) 1&lt;img src=&quot;http://latex.codecogs.com/svg.latex?\frac&#123;1&#125;&#123;1+sin(x)&#125;&quot;/&gt; =\frac{1}{1+e^{(-x)}})]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传本地文件到远程linux主机]]></title>
    <url>%2F2017%2F08%2F17%2F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[上传本地文件到远程linux主机命令scp /home/work/source.txt work@192.168.0.10:/home/work/ #把本地的source.txt文件拷贝到192.168.0.10机器上的/home/work目录下 scp work@192.168.0.10:/home/work/source.txt /home/work/ #把192.168.0.10机器上的source.txt文件拷贝到本地的/home/work目录下 scp work@192.168.0.10:/home/work/source.txt work@192.168.0.11:/home/work/ #把192.168.0.10机器上的source.txt文件拷贝到192.168.0.11机器的/home/work目录下 scp -r /home/work/sourcedir work@192.168.0.10:/home/work/ #拷贝文件夹，加-r参数 文件下载 wget http://www.linuxsense.org/xxxx/xxx.tar.gz wget -c http://www.linuxsense.org/xxxx/xxx.tar.gz -b：后台下载，Wget默认的是把文件下载到当前目录。 -O：将文件下载到指定的目录中。 -P：保存文件之前先创建指定名称的目录。 -t：尝试连接次数，当Wget无法与服务器建立连接时，尝试连接多少次。 -c：断点续传，如果下载中断，那么连接恢复时会从上次断点开始下载。 -r：使用递归下载]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Activity]]></title>
    <url>%2F2017%2F05%2F03%2FAndroid%20Activity%2F</url>
    <content type="text"><![CDATA[Android Activity一、Activity 的生命周期1、生命周期 （1）如果打开新的Activity并且新的Activity使用透明主题，那么当前Activity不会调用onStop。 （2）打开新的Activity时，当前Activity及新Activity生命周期顺序如下: 12345MainActivity----onPauseSecondActivity----onCreateSecondActivity----onStartSecondActivity----onResumeMainActivity----onStop 2、异常生命周期原因： （1）资源相关的系统配置发生改变导致的Activity被杀死并重新创建。 如：旋转屏幕，键盘改变等..… （2) 资源内存不足导致低优先级的Activity被杀死。 Activty优先级顺序 1、前台Activty,正在和用户交互的Activity，优先级最高。 2、可见但非前台Activity，如在Activity中弹出对话框。 3、后台Activity，如执行了onStop()，优先级最低。 解决 （1）在onSaveInstanceState(),onRestoreInstanceState()保存恢复数据 （2）在android 工程目录下AndroidManifest中配置如下: 1android:configChanges=&quot;screenSize|orientation&quot; configChanges：如下 项目 含义 mcc IMSI(国际移动用户识别码)发生改变，检测到SIM卡，或者更新MCC mnc IMSI网络发生改变,检测到SIM卡，或者更新MCC locale 语言发生改变，用户选择了一个新的语言，文字应该重新显示 touchscreen 触摸屏发生改变，这通常是不应该发生的 keyboard 键盘类型发生改变，例如，用户使用了外部键盘 keyboardHidden 键盘发生改变，例如，用户使用了硬件键盘 navigation 导航发生改变 screenLayout 屏幕的布局发生改变，这可能导致激活不同的显示 fontScale 全局字体大小缩放发生改变 orientation 设备旋转，横向显示和竖向显示模式切换 screenSize 屏幕大小改变了 smallestScreenSize 屏幕的物理大小改变了，如：连接到一个外部的屏幕上 二、启动模式1，standard 标准模式 每启动一个Activity都会重新创建一个新的Activity实例。当一个Activity启动这种模式下新的Activity，新的Activity就会进入启动它Activity的任务栈中。 2，singleTop 栈定复用模式这种模式下，如果新的Activity的实例已经位于任务栈的栈顶，那么新的Activity就不会重新创建，此时它的onNewIntent()被调用。如果新的Activity的实例不位于栈顶，那么就会重新创建。 3，singleTask 栈内复用模式这是一种单一任务栈。，系统会创建一个新的任务，并将启动的Activity放入这个新任务的栈底位置。但是，如果现有任务当中已经存在一个该Activity的实例了，那么系统就不会再创建一次它的实例，而是复用这个已经存在的activity，调用 onNewIntent() 方法，并且清空这个activity任务栈上面所有的activity 4，singleInstance 单实例模式单实例模式。这种模式下的Activity只单独的位于独立的任务栈中。整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity共享 公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在 Activity的Flage 1.FLAGE_ACTIVITY_NEW_TASK 新启动Activity就会被放置到一个新的任务当中(与“singleTask”有点类似） 2.FLAGE_ACTIVITY_SINGLE_TOP 作用于singleTop启动模式效果一样 3.FLAGE_ACTIVITY_CLEAR_TOP 如果要启动的Activity在当前任务中已经存在了，就不会再次创建这个Activity的实例，而是会把这个Activity之上的所有Activity全部关闭掉 三、任务栈处理任务栈处理affinity affinity可以用于指定一个Activity更加愿意依附于哪一个任务，在默认情况下，同一个应用程序中的所有Activity都具有相同的affinity，所以，这些Activity都更加倾向于运行在相同的任务当中。当然了，你也可以去改变每个Activity的affinity值，通过元素的taskAffinity属性就可以实现了 alwaysRetainTaskState如果将最底层的那个Activity的这个属性设置为true，那么上面所描述的默认行为就将不会发生，任务中所有的Activity即使过了很长一段时间之后仍然会被继续保留。 clearTaskOnLaunch如果将最底层的那个Activity的这个属性设置为true，那么只要用户离开了当前任务，再次返回的时候就会将最底层Activity之上的所有其它Activity全部清除掉。简单来讲，就是一种和alwaysRetainTaskState完全相反的工作模式，它保证每次返回任务的时候都会是一种初始化状态，即使用户仅仅离开了很短的一段时间。 finishOnTaskLaunch这个属性和clearTaskOnLaunch是比较类似的，不过它不是作用于整个任务上的，而是作用于单个Activity上。如果某个Activity将这个属性设置成true，那么用户一旦离开了当前任务，再次返回时这个Activity就会被清除掉。 四、Activity启动方式1、显示启动 显示启动需要明确的指定被启动对象的组件信息，包括包名和类名 2、隐式启动 隐式启动的Intent能够匹配目标组件的一组IntentFilter中的信息（即匹配一组IntentFilter的 Action,Category,Data）。 在AndroidManifest.xml中一个activity 可以有多个IntentFilter 在IntentFilter中也可以有多组Action,Category,Data IntentFilter中匹配规则 IntentFilter有“Action,Category,Data”的三种匹配方式 1234567public void playMedia(Uri file) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(file); if (intent.resolveActivity(getPackageManager()) != null) &#123; startActivity(intent); &#125;&#125; 12345678&lt;activity ...&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;data android:type=&quot;audio/*&quot; /&gt; &lt;data android:type=&quot;application/ogg&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 五、扩展架构组件数据库 RoomLiveDataViewModel参考： [1]、Activity Lifecycle [2]、Android Tasks and Back Stack [3]、Android Activities [4]、Android Intents [4]、Android intents-filter]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android broadcast]]></title>
    <url>%2F2017%2F04%2F17%2FAndroid%20%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[Android BroadcastBroadcast是一个全局的监听器，主要用于监听/ 接收应用发出的广播消息。广播采用订阅-发布设计模式（观察者设计模式），故广播有2个组成重要部分：sendBroadcast和broadcastReceiver。 注册广播1、静态注册注册： 123456&lt;receiver android:name=".MyBroadcastReceiver" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt; &lt;action android:name="android.intent.action.INPUT_METHOD_CHANGED" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 使用： 123456789101112public class MyBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = "MyBroadcastReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; StringBuilder sb = new StringBuilder(); sb.append("Action: " + intent.getAction() + "\n"); sb.append("URI: " + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + "\n"); String log = sb.toString(); Log.d(TAG, log); Toast.makeText(context, log, Toast.LENGTH_LONG).show(); &#125; &#125; 系统在安装应用程序时注册接收器。如果应用程序当前未运行，系统可以启动应用程序并发送广播。 2、动态注册1BroadcastReceiver br = new MyBroadcastReceiver(); 123IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);this.registerReceiver(br, filter); 1unregisterReceiver(br) 发送广播1、普通广播sendBroadcast：已未定义的顺序向所有接收器发送广播 1234Intent intent = new Intent();intent.setAction(&quot;com.example.broadcast.MY_NOTIFICATION&quot;);intent.putExtra(&quot;data&quot;,&quot;Notice me senpai!&quot;);sendBroadcast(intent); 2、有序广播sendOrderedBroadcast(Intent, String)一次向一个接收器发送广播。当每个接收器依次执行时，它可以将结果传播到下一个接收器，或者它可以完全中止广播，以便它不会传递给其他接收器。通过intent-filter的android:priority属性来设置广播的优先级; 具有相同优先级的接收器将以任意顺序运行。 应用示例：短信广播 3、本地广播即在本应用（同一进程）内发送广播。注意，本地广播只能通过动态注册。 1LocalBroadcastManager.sendBroadcast(Intent) 4、系统广播系统广播 是有 系统 发送的一种形式的广播，开发者无法使用只能接受系统广播。 5、粘粘广播Sticky Broadcast 高版本API上以废弃，不建议使用。 1sendStickyBroadcast(intent); 广播的权限管理在默认的情况下Android 的广播是可以IPC通信（含应用间通信），这种情况下其他app（非目标app）可以接受到你的广播信息从而产生安全隐患也会造成一定的性能开销。 1、应用内的广播通信应用内的广播 不想 被其他app 知晓时。可以考虑使用LocalBroadcast, 2、指定应用间的广播通信、 不接收其他app 的广播 静态注册的情况下，设置：`android:exported=”false” 、 发送给指定的app 的广播 在发送广播时在Intent 中指定报名Intent.setPackage(packageName) 、接收指定app 的广播 在接收指定广播时时可以设置接收广播的权限，如： 1、自定义权限：https://developer.android.com/guide/topics/manifest/permission-element.html 12345&lt;permission android:name="com.hello.permission.broadcast" android:label="@string/app_name" android:permissionGroup="@string/hello_world" android:protectionLevel="normal" &gt; 2、接收端使用自定义权限： 1&lt;uses-permission android:name="com.hello.permission.broadcast"/&gt; 3、发送带权限的广播 12sendBroadcast(new Intent("com.example.NOTIFY"), "com.hello.permission.broadcast"); 4、接收带权限的广播 123456&lt;receiver android:name=".MyBroadcastReceiver" android:permission="com.hello.permission.broadcast"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.AIRPLANE_MODE"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 或 12IntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);registerReceiver(receiver, filter, "com.hello.permission.broadcast", null ); 此时广播接收器只能接收相同权限的广播 。 广播扩展知识1、比较静态注册和动态注册 静态注册 动态注册 注册方式 AndroidManifest.xml 代码中注册 生命周期 不受任何组件的生命周期影响，即使app关闭也可以唤醒接收 跟随组件的生命周期变化而变化，需要动态注销 应用场景 需要实时监听广播，如系统广播 需要动态监听广播，如监听文件下载的变化等 2、广播的注意事项广播接收者中不能进行耗时操作，否者会出现AN异常。如果需要执行耗时操作需要在线程中执行。例如： 1234567891011121314151617181920212223242526272829303132333435363738public class MyBroadcastReceiver extends BroadcastReceiver &#123; private static final String TAG = "MyBroadcastReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; final PendingResult pendingResult = goAsync(); Task asyncTask = new Task(pendingResult, intent); asyncTask.execute(); &#125; private static class Task extends AsyncTask &#123; private final PendingResult pendingResult; private final Intent intent; private Task(PendingResult pendingResult, Intent intent) &#123; this.pendingResult = pendingResult; this.intent = intent; &#125; @Override protected String doInBackground(String... strings) &#123; StringBuilder sb = new StringBuilder(); sb.append("Action: " + intent.getAction() + "\n"); sb.append("URI: " + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + "\n"); String log = sb.toString(); Log.d(TAG, log); return log; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); // Must call finish() so the BroadcastReceiver can be recycled. pendingResult.finish(); &#125; &#125;&#125; 3、广播的通信原理广播中通信与Servce中的通信原理都是使用IBinder机制实现的。这里不在过度展开，会另起篇章来深度讨论IBinder机制 参考： [1]、Android Broadcasts [2]、Android Permission]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 事件分发]]></title>
    <url>%2F2017%2F04%2F09%2FAndroid%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Android 事件分发在梳理Android事件分发之前，我们先要理解什么是 事件分发，理解事件分发对我们有哪些作用。首先Android View是树形结构的，View可能会重叠在一起，当我们点击的地方有多个View都可以响应, Android 中事件分发指的是 点击事件 从点击开始分发到 事件被消费响应的一系列过程，当中包括 事件的分发，拦截，消费等过程。掌握好事件分发的过程可以做出酷炫的交互和解决一些复杂的交互冲突过程如 双重滚动嵌套。 View 体系在理解 事件分发之前我们先看一下View的体系。 phoneWindow是Android 中特殊的window，它继承自window类负责具体所有视图的外观和行为。 DecorView是window的具体装饰，是window中最顶层的view。 RootView是一个ViewGorup类型，仅次于 DecorView 的view。 1234567// 源码 phonwWindow.java ,省略部分代码。public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; private final static String TAG = "PhoneWindow"; // This is the top-level view of the window, containing the window decor. private DecorView mDecor; 1234567//源码 DecorView.java ,省略部分代码。public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; private static final String TAG = "DecorView"; private PhoneWindow mWindow; ViewGroup mContentRoot; 到这里虽然我们了解了phoneWindow,DecorView,RootView，但是事件分发中我们无法操作这三个类，不过 可以帮助我们更好的理解分发的过程。 事件分发ViewGroup，View是我们常用到的控件，这里不在过多的描述，重点关注 事件分发中需要用到的关键方法。 类型 相关方法 Activity ViewGroup View 事件分发 dispatchTouchEvent √ √ √ 事件拦截 onInterceptTouchEvent X √ X 事件消费 onTouchEvent √ √ √ 结合View体系，我们可以了解事件分发的基本流程。 1Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 当事件没有被消费是，向上反馈。 1Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View 到这里，事件分发的基本流程已经完。有时间再补一下完善一点的事件分发的流程吧。 参考： [1]、http://www.gcssloop.com/customview/dispatch-touchevent-source [2]、http://hukai.me/android-deeper-touch-event-dispatch-process/ [3]、 Android 源码 [4]、https://www.programering.com/a/MzMyYzMwATA.html [5]、https://juejin.im/entry/5a33399f6fb9a04517053e75]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 整理]]></title>
    <url>%2F2017%2F03%2F22%2Freact%20native%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[文档react-native 官网 https://facebook.github.io/react-native/ react-native 中文 https://reactnative.cn/ react-native-community https://github.com/react-native-community ReactNative指南 https://github.com/reactnativecn/react-native-guide 工具Expo https://expo.io/ react-native-code-push https://github.com/Microsoft/react-native-code-push UI 框架/组件轮播组件 https://github.com/leecade/react-native-swiper 跨平台UI 组件NativeBase https://github.com/GeekyAnts/NativeBase 跨平台UI 组件ReactNativeElements https://github.com/react-native-training/react-native-elements https://react-native-training.github.io/react-native-elements/ 跨平台UI 组件Shoutem https://shoutem.github.io/docs/ui-toolkit/introduction 跨平台UI 组件kitten https://github.com/akveo/react-native-ui-kitten https://akveo.github.io/react-native-ui-kitten/#/home 跨平台UI 组件MaterialUI https://github.com/xotahal/react-native-material-ui 图标库VectorIcons https://github.com/oblador/react-native-vector-icons 图表ChartsWrapper https://github.com/wuxudong/react-native-charts-wrapper 动画Lottie https://github.com/react-native-community/lottie-react-native Spinkit https://github.com/maxs15/react-native-spinkit SampleF8App https://github.com/fbsamples/f8app http://makeitopen.com/ Reading https://github.com/attentiveness/reading]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Marketdown 语法]]></title>
    <url>%2F2016%2F08%2F13%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown概况Markdown 是由 Daring Fireball 创建的轻量级标记语言 段落和换行符段落由多个空行分隔 标题标题在行的开头使用 1-6 个 # 对应标题1-6个级别，例如： 12345# 一级标题 H1## 二级标题 H2###### 六级标题 H6 另一种使用方式, 在一行中使用多个连续的 #表示 一级标题 ，使用连续的-表示 二级标题。例如： 12一级标题=============== 12二级标题--------------- 分割线使用 *** 或 --- 表示分割线，例如： 1---- 显示如下： 引用 使用 &gt; 表示引用。 123&gt; 引用1&gt; 引用2 列表使用 * 表示无序列表，或者使用 + 或 - 替代。 使用数字如1. 表示有序列表。例如： 123456789## 无序列表* Red* Green* Blue## 有序列表1. Red2. Green3. Blue 任务列表任务列表使用- [ ] 或- [x] 表示任务的未完成 或 完成 状态。 例如： 12- [ ] 未完成 任务选项- [x] 完成 任务选项 代码块使用 一对 ` 表示单行代码，使用一对 多行代码。 例如：123456~~~ gfm单行代码示例：my function name is ` test() `多行代码示例： function test() { console.log(“notice the blank line before this function?”);}123456代码高亮（代码类型）:```rubyrequire &apos;redcarpet&apos;markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html ~~~ 如果需要在代码中使用单引号，需要使用来规避，例如： 1``这个 `代码` 是错误的`` 显示如下： 这个 `代码` 是错误的 表格示例: 123| 标题1 | 标题1 || ----- | ----- || 内容1 | 内容2 | 在标题和内容间的—— 添加 : 表示对齐方式，如:----- 左对齐、:-----:居中对齐，-----:右对齐，例如： 12345| 左对齐 | 居中对齐 | 右对齐 || :----- |:-----:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 链接使用[]()组成。例如： 1[示例网址](http://example.com/) 显示如下： 示例网址 图片使用![]()组成。例如： 1234# 图片相对路径![本地图片](/path/img.png)# 图片http 路径![网络图片](https://d33wubrfki0l68.cloudfront.net/e7ed9fe4bafe46e275c807d63591f85f9ab246ba/e2d28/assets/images/tux.png) 斜体使用 单个* 或单个 (_) 表示斜体，例如： 1*斜体1* 显示如下： 斜体1 粗体使用一对**表示粗体，例如： 1**粗体** 粗体 删除线使用一对~~ 表示删除线（非标准语法，GFM中使用） 1~~不要了~~ 显示如下： 不要了 下划线可以使用html标签&lt;u&gt; &lt;/u&gt;表示，例如： 1&lt;u&gt; 下划线 &lt;/u&gt; 显示如下： 下划线 下标使用 ~表示下标， 例如: 1H~2~O X~long\ text~ 显示如下： H~2~O X~long\ text~ 上标使用 ^ 表示上标, 例如: 1X^2^ 显示如下： X^2^ 高亮使用 == 表示高亮， 例如: 1==高亮文字== 显示如下： ==高亮文字== Html 片段例如 ：1&lt;span style=&quot;color:red&quot;&gt;红色文字&lt;/span&gt; 显示如下： 红色文字 反义使用\ 反义 markdown中的关键字，例如： 1\* 如果没有反斜杠,这将是无序列表 显示如下： * 如果没有反斜杠,这将是无序列表 可以使用反义的关键字 字符 名称 \ 反斜线 ` 刻度线 * 星号 _ 下划线 {} 大括号 [] 括号 () 括弧 # 英镑符号 + 加号 - 减号（连字符） . 点 ! 感叹号 参考网址： [1]、markdownguide]]></content>
      <categories>
        <category>Marketdown</category>
      </categories>
      <tags>
        <tag>Marketdown</tag>
      </tags>
  </entry>
</search>
